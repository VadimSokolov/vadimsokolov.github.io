{
  "hash": "08bf629ff40c69f8c9f94aec98cb1d52",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"The Secretary Problem\"\nsubtitle: \"Optimal Stopping in Decision Theory\"\nauthor: \"Vadim Sokolov\"\nformat: \n  revealjs:\n    theme: sky\n    transition: slide\n    scrollable: true\n---\n\n## Introduction\n\n- The **Secretary Problem** (marriage problem, sultan's dowry problem).\n- Classic problem in decision theory and probability.\n- **Scenario:** Select the best candidate from $T$ sequential offers.\n\n## The Rules\n\n1. You receive $T$ offers one by one.\n2. You must **accept or reject** on the spot.\n3. You **cannot return** to a previous offer.\n4. Aim: **Maximize the probability** of choosing the absolute best.\n\n## The 37% Rule\n\n- **Strategy:** Reject the first $r$ candidates to gain information, then pick the next one better than all previous.\n- **Optimal $r$:** $r \\approx T/e \\approx 0.37 T$.\n- One should reject the first 37% of candidates and then select the first one who is better than all those seen so far.\n\n## Mathematical Background\n\n- Principle of optimality (Richard Bellman).\n- Probability of success:\n$$\nP(\\text{success}) = \\frac{r}{T} \\sum_{a=r+1}^T \\frac{1}{a-1} \\approx \\frac{r}{T} \\int_{r}^{T} \\frac{1}{x} dx = \\frac{r}{T} \\log \\left( \\frac{T}{r} \\right)\n$$\n- Maximize $f(x) = x \\log(1/x) \\implies x = 1/e \\approx 0.37$.\n\n## Simulation in Python\n\n::: {#f3993a51 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef secretary_simulation(n=100, nmc=1000):\n    np.random.seed(17)\n    rules = np.unique(np.round(n * np.linspace(0.01, 0.8, 50)).astype(int))\n    rules = rules[rules > 0]\n    \n    success_rate = np.zeros(len(rules))\n    \n    for i, r in enumerate(rules):\n        for _ in range(nmc):\n            candidates = np.random.permutation(np.arange(1, n + 1))\n            screen = candidates[:r]\n            best_screen = np.max(screen) if len(screen) > 0 else 0\n            choices = candidates[r:]\n            selected = None\n            for c in choices:\n                if c > best_screen:\n                    selected = c\n                    break\n            if selected is None:\n                selected = candidates[-1]\n            if selected == n:\n                success_rate[i] += 1\n    return rules, success_rate / nmc\n\nrules, prob_best = secretary_simulation()\n```\n:::\n\n\n## Simulation Results\n\n::: {#c529cacc .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](secretary_problem_slides_files/figure-revealjs/cell-3-output-1.png){width=821 height=523}\n:::\n:::\n\n\n## Key Takeaways\n\n- Balance **exploration** (the first 37%) and **exploitation** (choosing the first best).\n- The maximum probability of success is also approximately **37%**.\n- This rule applies to many sequential decision-making scenarios.\n\n",
    "supporting": [
      "secretary_problem_slides_files"
    ],
    "filters": [],
    "includes": {}
  }
}