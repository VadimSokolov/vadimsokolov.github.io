<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Model Selection – Bayes, AI and Deep Learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./00-intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-680e7c22d93ef26f016bec9199f8e6d8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
</head><body class="nav-sidebar docked quarto-light"><div class="hidden">
<p><span class="math display">\[
\newcommand{\prob}[1]{\operatorname{P}\left(#1\right)}
\newcommand{\Var}[1]{\operatorname{Var}\left(#1\right)}
\newcommand{\sd}[1]{\operatorname{sd}\left(#1\right)}
\newcommand{\Cor}[1]{\operatorname{Corr}\left(#1\right)}
\newcommand{\Cov}[1]{\operatorname{Cov}\left(#1\right)}
\newcommand{\E}[1]{\operatorname{E}\left(#1\right)}
\newcommand{\defeq}{\overset{\text{\tiny def}}{=}}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\mini}{minimize}
\DeclareMathOperator*{\minf}{minimize \quad}
\newcommand{\mininlineeq}[4]{\begin{equation}\label{#4}\mbox{minimize}_{#1}\quad#2\qquad\mbox{subject to }#3\end{equation}}
\]</span></p>
</div>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>





<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./19-select.html">Deep Learning</a></li><li class="breadcrumb-item"><a href="./19-select.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Model Selection</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Bayes, AI and Deep Learning</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Principles of Data Science</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Deep Learning</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19-select.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Model Selection</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#prediction-vs-interpretation" id="toc-prediction-vs-interpretation" class="nav-link active" data-scroll-target="#prediction-vs-interpretation"><span class="header-section-number">1.1</span> Prediction vs Interpretation</a>
  <ul class="collapse">
  <li><a href="#breimans-two-cultures" id="toc-breimans-two-cultures" class="nav-link" data-scroll-target="#breimans-two-cultures"><span class="header-section-number">1.1.1</span> Breiman’s Two Cultures</a></li>
  </ul></li>
  <li><a href="#what-makes-a-good-predictive-model" id="toc-what-makes-a-good-predictive-model" class="nav-link" data-scroll-target="#what-makes-a-good-predictive-model"><span class="header-section-number">1.2</span> What makes a good predictive model?</a></li>
  <li><a href="#out-of-sample-performance" id="toc-out-of-sample-performance" class="nav-link" data-scroll-target="#out-of-sample-performance"><span class="header-section-number">1.3</span> Out of Sample Performance</a></li>
  <li><a href="#bias-variance-trade-off" id="toc-bias-variance-trade-off" class="nav-link" data-scroll-target="#bias-variance-trade-off"><span class="header-section-number">1.4</span> Bias-Variance Trade-off</a></li>
  <li><a href="#cross-validation" id="toc-cross-validation" class="nav-link" data-scroll-target="#cross-validation"><span class="header-section-number">1.5</span> Cross-Validation</a></li>
  <li><a href="#bayesian-model-selection" id="toc-bayesian-model-selection" class="nav-link" data-scroll-target="#bayesian-model-selection"><span class="header-section-number">1.6</span> Bayesian Model Selection</a>
  <ul class="collapse">
  <li><a href="#the-bayesian-information-criterion" id="toc-the-bayesian-information-criterion" class="nav-link" data-scroll-target="#the-bayesian-information-criterion"><span class="header-section-number">1.6.1</span> The Bayesian Information Criterion</a></li>
  <li><a href="#nic-and-evidence-framework" id="toc-nic-and-evidence-framework" class="nav-link" data-scroll-target="#nic-and-evidence-framework"><span class="header-section-number">1.6.2</span> NIC and evidence framework</a></li>
  </ul></li>
  <li><a href="#widely-applicable-bayesian-information-criterion" id="toc-widely-applicable-bayesian-information-criterion" class="nav-link" data-scroll-target="#widely-applicable-bayesian-information-criterion"><span class="header-section-number">1.7</span> Widely applicable Bayesian Information Criterion</a>
  <ul class="collapse">
  <li><a href="#motivation-for-wbic" id="toc-motivation-for-wbic" class="nav-link" data-scroll-target="#motivation-for-wbic"><span class="header-section-number">1.7.1</span> Motivation for WBIC</a></li>
  <li><a href="#practical-implementation" id="toc-practical-implementation" class="nav-link" data-scroll-target="#practical-implementation"><span class="header-section-number">1.7.2</span> Practical Implementation</a></li>
  </ul></li>
  <li><a href="#double-descent" id="toc-double-descent" class="nav-link" data-scroll-target="#double-descent"><span class="header-section-number">1.8</span> Double Descent</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./19-select.html">Deep Learning</a></li><li class="breadcrumb-item"><a href="./19-select.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Model Selection</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Model Selection</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>“<em>When you have eliminated impossible, whatever remains, however improbable, must be the truth.</em>” - Sherlock Holmes</p>
</blockquote>
<p>In the world of statistical modeling and machine learning, we face a fundamental challenge that echoes Sherlock Holmes’ famous words about eliminating the impossible to find the truth. When confronted with data, we must navigate through countless possible models, each representing a different hypothesis about the underlying relationships in our data. The art and science of model selection lies in systematically choosing the model that best captures the true signal while avoiding the trap of fitting noise. This chapter explores the critical decisions on how to choose the right model.</p>
<p>In previous chapter <span class="quarto-unresolved-ref">?sec-regularization</span> we focussed on regularization techniques, which also can be viewd as a model selection mechanis. Specifically, we will discuss Ridge regression, LASSO, and their Bayesian interpretations. These methods offer elegant solutions to the overfitting problem by introducing penalties for model complexity, automatically balancing fit and parsimony. We’ll see how these frequentist approaches connect to Bayesian thinking through the lens of prior distributions and posterior inference.</p>
<p>We begin by examining the fundamental considerations that guide model selection: the bias-variance tradeoff, the challenges of overfitting and underfitting, and the practical constraints of computational resources and data quality. We’ll explore how the purpose of our analysis—whether prediction or interpretation—should influence our modeling choices, drawing on Leo Breiman’s influential distinction between the “two cultures” of statistical modeling.</p>
<p>The chapter then delves into practical methodologies for model evaluation and selection. We’ll cover exploratory data analysis techniques that help us understand our data before committing to a particular model form, followed by rigorous approaches to measuring out-of-sample performance through cross-validation and information criteria. These tools provide the foundation for making principled decisions about model complexity.</p>
<p>By the end of this chapter, you’ll have a comprehensive toolkit for approaching model selection problems, understanding when different techniques are appropriate, and implementing these methods in practice. Most importantly, you’ll develop the judgment to balance the competing demands of accuracy, interpretability, and computational efficiency that characterize real-world modeling challenges.</p>
<p>Let us start with several important considerations when building predictive models.</p>
<p><strong>1. Model Selection:</strong> Choosing the right model for the relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is crucial and involves navigating a fundamental trade-off between model complexity and generalization ability. If the chosen model is too simple (e.g., linear regression when the true relationship is polynomial), it might underfit the data and fail to capture important relationships, leading to high bias and poor performance on both training and test data. Conversely, a model that is too complex (e.g., high-degree polynomials or deep neural networks with insufficient data) might overfit the data by memorizing training examples rather than learning the underlying pattern, resulting in excellent training performance but poor generalization to unseen examples. This problem becomes even more complex when dealing with non-linear relationships, high-dimensional data, or noisy data, where the optimal model complexity is not immediately obvious and may require systematic experimentation with different model architectures, regularization techniques, and hyperparameter tuning to find the right balance between capturing the true signal while avoiding noise.</p>
<p><strong>2. Overfitting and Underfitting:</strong> Overfitting occurs when the model fits the training data too closely, capturing not only the true underlying relationship but also random noise and idiosyncrasies specific to the training dataset. This phenomenon typically manifests when a model has too many parameters relative to the amount of training data available, allowing it to essentially “memorize” the training examples rather than learning the generalizable patterns. The model may achieve excellent performance metrics on the training data (low training error) but will perform poorly on new, unseen data (high generalization error). This is because the model has learned to recognize specific noise patterns in the training data that don’t exist in the broader population. Common signs of overfitting include a large gap between training and validation/test performance, or performance that improves on training data while degrading on validation data during training iterations.</p>
<p>Underfitting occurs when the model is too simple and fails to capture the true relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, often due to insufficient model complexity or inadequate training. This can happen when using a model that is inherently too simple for the problem at hand (e.g., linear regression for a highly non-linear relationship), when the model hasn’t been trained for enough iterations, or when regularization is applied too aggressively. Underfitting results in poor performance on both training and test data, as the model lacks the capacity to learn the underlying patterns in the data. The model essentially misses important features or relationships that are necessary for accurate predictions. Unlike overfitting, underfitting typically shows similar poor performance across training, validation, and test sets, indicating that the model is not capturing the signal in the data regardless of the dataset.</p>
<p><strong>3. Data Quality and Quantity:</strong> The accuracy of predictions heavily relies on the quality and quantity of the available data. If the data is noisy, inaccurate, or incomplete, it can lead to misleading predictions. A sufficient amount of data is also crucial to ensure the model can learn the underlying relationship effectively. Insufficient data can result in underfitting and poor generalization.</p>
<p>Data quality issues can manifest in various forms, including missing values, inconsistent formatting, labeling errors, and biased sampling. These problems are particularly acute in machine learning applications where large volumes of labeled data are required for training. To address these challenges, companies have emerged that specialize in data quality improvement and annotation services.</p>
<p>Companies like Scale AI and Toloka provide platforms that help organizations improve data quality through human-in-the-loop annotation and validation processes. These platforms employ large networks of human annotators who can perform tasks such as image labeling, text classification, data validation, and quality control. Scale AI, for example, offers services for creating high-quality training datasets through human annotation, with built-in quality control mechanisms that include multiple annotators per task and consensus-based validation. Their platform can handle various data types including images, text, and video, making it suitable for computer vision, natural language processing, and other AI applications.</p>
<p>Toloka, similarly, provides a crowdsourcing platform that connects businesses with a global network of contributors who can perform data labeling, content moderation, and quality assessment tasks. Their platform includes quality control features such as skill-based routing, where tasks are assigned to annotators based on their demonstrated expertise, and dynamic overlap, where multiple workers verify the same data to ensure accuracy.</p>
<p>These platforms help address several key data quality challenges: they can identify and correct labeling errors through consensus mechanisms, handle missing data through targeted collection efforts, and ensure consistency in data formatting and annotation standards. By leveraging human expertise at scale, these services enable organizations to create more reliable training datasets, which in turn leads to better-performing machine learning models and more accurate predictions.</p>
<p><strong>4. Model Explainability:</strong> In many applications, it is crucial to understand how the model arrives at its predictions. This is particularly important in areas like healthcare or finance, where transparency and interpretability are essential. Some models, particularly complex ones like deep neural networks, can be difficult to interpret, making it challenging to understand the rationale behind their predictions. However, modern machine learning has developed several techniques to address this challenge and make complex models more interpretable.</p>
<p>The importance of explainability extends beyond mere curiosity about model behavior. In healthcare applications, doctors need to understand why a model recommended a particular diagnosis or treatment plan to make informed decisions and maintain trust in the system. A model that predicts a patient has a 90% chance of having cancer but cannot explain which symptoms or test results led to this conclusion would be of limited clinical value. Similarly, in financial services, regulators require explanations for credit decisions to ensure compliance with fair lending laws and to prevent discriminatory practices. When a loan application is denied, both the applicant and regulatory bodies need to understand the specific factors that influenced this decision.</p>
<p>In legal and compliance contexts, explainability becomes a legal requirement. The European Union’s General Data Protection Regulation (GDPR) includes a “right to explanation” that allows individuals to request information about automated decisions that affect them. This has created a legal imperative for organizations to develop explainable AI systems. In criminal justice applications, where AI systems might be used for risk assessment or sentencing recommendations, the stakes are particularly high. Judges, lawyers, and defendants all need to understand how these systems arrive at their conclusions to ensure fair and just outcomes.</p>
<p>One prominent approach is the use of interpretable surrogate models, such as LIME (Local Interpretable Model-agnostic Explanations) and SHAP (SHapley Additive exPlanations). These methods work by approximating the complex model’s behavior in the vicinity of a specific prediction using simpler, more interpretable models like linear regression or decision trees. LIME, for instance, creates local explanations by sampling points around the prediction of interest and fitting a linear model to explain the model’s behavior in that neighborhood. This allows us to understand which features contributed most to a particular prediction, even for complex models like deep neural networks.</p>
<p>Another powerful technique is attention mechanisms, which have become increasingly popular in natural language processing and computer vision. Attention mechanisms allow models to “focus” on specific parts of the input when making predictions, providing a form of built-in interpretability. For example, in image classification tasks, attention maps can highlight which regions of an image the model is focusing on when making its prediction, making it easier to understand the model’s decision-making process.</p>
<p>Gradient-based methods offer another approach to model interpretability. Techniques like Grad-CAM (Gradient-weighted Class Activation Mapping) use gradients to identify which parts of the input are most important for the model’s prediction. By computing the gradient of the model’s output with respect to the input features, these methods can create heatmaps that show which features or regions contributed most to the final prediction.</p>
<p>For tree-based models like random forests and gradient boosting machines, built-in feature importance measures provide natural interpretability. These methods can rank features based on their contribution to the model’s predictive performance, offering insights into which variables are most important for making predictions.</p>
<p>Model distillation techniques represent another approach, where a complex model (the teacher) is used to train a simpler, more interpretable model (the student) that mimics the teacher’s behavior. The student model, being simpler, is easier to interpret while maintaining much of the teacher’s predictive performance.</p>
<p>Finally, counterfactual explanations provide a different type of interpretability by showing what changes to the input would be needed to change the model’s prediction. For example, if a loan application is rejected, a counterfactual explanation might show that the application would have been approved if the applicant’s income were $10,000 higher or if their credit score were 50 points better.</p>
<p>These modern interpretability techniques have made it possible to understand and explain the behavior of even the most complex models, addressing the “black box” problem that has historically limited the adoption of advanced machine learning methods in critical applications where transparency is essential.</p>
<p><strong>5. Computational Cost:</strong> Training and using prediction models can be computationally expensive, especially for complex models with large datasets. This can limit their applicability in resource-constrained environments. Finding a balance between model complexity, accuracy, and computational cost is critical for practical applications.</p>
<p>The computational demands of machine learning models have been significantly addressed through the development of specialized hardware, particularly Graphics Processing Units (GPUs). Originally designed for rendering graphics in video games, GPUs have become essential for deep learning due to their parallel processing architecture. Unlike traditional Central Processing Units (CPUs) that process tasks sequentially, GPUs can perform thousands of mathematical operations simultaneously, making them ideal for the matrix multiplications and tensor operations that are fundamental to neural network training. This parallel processing capability has reduced training times from weeks to hours or even minutes for many deep learning models, democratizing access to advanced machine learning techniques.</p>
<p>However, the computational cost challenge extends beyond just training to the deployment phase, where models need to run efficiently in production environments. This has led to the emergence of edge computing as a crucial solution. Edge computing involves processing data and running models closer to where the data is generated, rather than sending everything to centralized cloud servers. This approach offers several advantages for machine learning applications: reduced latency for real-time predictions, lower bandwidth costs by processing data locally, and improved privacy by keeping sensitive data on local devices.</p>
<p>Edge computing is particularly important for applications requiring real-time decision making, such as autonomous vehicles, industrial IoT systems, and mobile applications. For example, a self-driving car cannot afford the latency of sending sensor data to a cloud server and waiting for predictions to return; it needs to process information and make decisions locally within milliseconds. Similarly, smart manufacturing systems use edge computing to monitor equipment and predict maintenance needs in real-time without the delays associated with cloud processing.</p>
<p>Quantization and lower precision calculations have emerged as powerful techniques for reducing computational costs while maintaining model performance. Traditional neural networks use 32-bit floating-point numbers (FP32) for all calculations, which provides high precision but requires significant computational resources and memory. Quantization reduces the precision of these numbers, typically to 16-bit (FP16), 8-bit integers (INT8), or even 4-bit integers (INT4), dramatically reducing both memory usage and computational requirements. For example, converting from FP32 to INT8 can reduce memory usage by 75% and computational cost by 2-4x, while often maintaining acceptable accuracy levels. This is particularly valuable for deployment on edge devices with limited resources, such as smartphones, IoT devices, and embedded systems. Modern hardware, including specialized AI accelerators like Google’s Tensor Processing Units (TPUs) and NVIDIA’s Tensor Cores, are specifically designed to handle these lower precision calculations efficiently, further reducing the computational cost barrier.</p>
<p>The trade-offs between computational cost and model performance are becoming increasingly sophisticated. Techniques like model pruning, which removes unnecessary connections from neural networks, can create smaller, faster models. Knowledge distillation allows large, complex models to transfer their knowledge to smaller, more efficient models that can run on resource-constrained devices.</p>
<p>These developments have created a spectrum of deployment options, from powerful cloud-based systems that can run the most complex models to lightweight edge devices that can perform basic predictions locally. The choice depends on the specific requirements of the application, including latency requirements, accuracy needs, privacy concerns, and cost constraints. As hardware continues to improve and optimization techniques become more sophisticated, the computational cost barrier to deploying machine learning models continues to decrease, opening up new possibilities for AI applications in previously inaccessible domains.</p>
<p><strong>6. Ethical Considerations:</strong> Predictions can have significant real-world consequences, raising ethical concerns about bias, fairness, and potential misuse. It is crucial to consider the potential harms and unintended consequences of predictions and implement safeguards to mitigate them.</p>
<p>The ethical implications of predictive models have become increasingly prominent as these systems are deployed in critical domains such as healthcare, criminal justice, employment, and financial services. One of the most significant concerns is algorithmic bias, which can perpetuate or amplify existing societal inequalities. For example, facial recognition systems have been shown to have higher error rates for people of color, potentially leading to wrongful arrests or surveillance. Similarly, hiring algorithms trained on historical data may perpetuate gender or racial biases present in past hiring decisions, creating a feedback loop that reinforces discrimination.</p>
<p>Fairness in machine learning has emerged as a critical research area, with multiple definitions and approaches to ensure equitable treatment across different demographic groups. Statistical parity, equalized odds, and individual fairness are among the various fairness metrics that can be applied depending on the specific context and requirements of the application. However, achieving fairness often involves trade-offs with model accuracy, and different fairness definitions may conflict with each other, requiring careful consideration of which definition is most appropriate for a given use case.</p>
<p>The potential for misuse of predictive models is another significant concern. Models designed for legitimate purposes can be repurposed for harmful applications, such as using facial recognition for mass surveillance or employing predictive policing algorithms that disproportionately target certain communities. Additionally, the increasing sophistication of deepfake technology, which uses predictive models to generate realistic but fake images, videos, or audio, raises concerns about misinformation and manipulation.</p>
<p>Privacy concerns arise when predictive models require access to sensitive personal data. The collection, storage, and processing of personal information for training and deploying these models can violate individual privacy rights and create risks of data breaches. Differential privacy techniques, which add carefully calibrated noise to data or model outputs, have emerged as a promising approach to protect individual privacy while maintaining model utility.</p>
<p>Transparency and accountability are essential for addressing ethical concerns. Organizations deploying predictive models must be able to explain their decisions and be held accountable for any harms that result. This includes maintaining audit trails, implementing human oversight mechanisms, and establishing clear procedures for addressing complaints or errors. The concept of “algorithmic impact assessments” has been proposed as a framework for evaluating the potential social impacts of automated decision-making systems before deployment.</p>
<p>Regulatory frameworks are evolving to address these ethical challenges. The European Union’s General Data Protection Regulation (GDPR) includes provisions for automated decision-making and profiling, while various jurisdictions are developing specific regulations for AI systems. These regulations often require transparency, human oversight, and the ability to contest automated decisions.</p>
<p>Technical approaches to addressing ethical concerns include adversarial training to reduce bias, interpretability techniques to increase transparency, and robust testing procedures to identify potential harms before deployment. Regular monitoring and updating of deployed models is also crucial, as societal norms and legal requirements evolve over time.</p>
<p>Addressing these challenges requires careful consideration of the specific problem, selection of appropriate techniques, and continuous evaluation and improvement of the prediction model. It also requires collaboration between technical experts, domain specialists, ethicists, and stakeholders to ensure that predictive models serve the public good while minimizing potential harms.</p>
<!-- TODO: Discuss at the beginning of this chapter predictive rule can be used for two purposes -->
<section id="prediction-vs-interpretation" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="prediction-vs-interpretation"><span class="header-section-number">1.1</span> Prediction vs Interpretation</h2>
<p>As we have discussed at the beginning of this chapter the predictive rule can be used for two purposes: prediction and interpretation. The goal of interpretation is to understand the relationship between the input and output variables. The two goals are not mutually exclusive, but they are often in conflict. For example, a model that is good at predicting the target variable might not be good at interpreting the relationship between the input and output variables. A nice feature of a linear model is that it can be used for both purposes, unlike more complex predictive rules with many parameters that can be difficult to interpret.</p>
<p>Typically the problem of interpretation requires a simpler model. We prioritize models that are easy to interpret and explain, even if they have slightly lower predictive accuracy. Also, evaluation metrics are different, we typically use coefficient of determination (R-squared) or p-values, which provide insights into the model’s fit and the significance of the estimated relationships.</p>
<p>The choice between using a model for prediction or interpretation depends on the specific task and desired outcome. If the primary goal is accurate predictions, a complex model with high predictive accuracy might be preferred, even if it is less interpretable. However, if understanding the underlying relationships and causal mechanisms is crucial, a simpler and more interpretable model might be chosen, even if it has slightly lower predictive accuracy. Typically interpretive models are used in scientific research, social sciences, and other fields where understanding the underlying causes and relationships is crucial.</p>
<p>In practice, it’s often beneficial to consider both prediction and interpretation when building and evaluating models. However, it is not unusual to build two different models, one for prediction and one for interpretation. This allows for a more nuanced analysis of the data and can lead to better insights than using a single model for both purposes.</p>
<!-- TODO: Write text connecting Breiman's Two Cultures discussion -->
<section id="breimans-two-cultures" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="breimans-two-cultures"><span class="header-section-number">1.1.1</span> Breiman’s Two Cultures</h3>
<p>Let <span class="math inline">\(x\)</span> be a high dimensional input containing a large set of potentially relevant data. Let <span class="math inline">\(y\)</span> represent an output (or response) to a task which we aim to solve based on the information in <span class="math inline">\(x\)</span>. Brieman [2000] summaries the difference between statistical and machine learning philosophy as follows.</p>
<blockquote class="blockquote">
<p>“There are two cultures in the use of statistical modeling to reach conclusions from data. One assumes that the data are generated by a given stochastic data model. The other uses algorithmic models and treats the data mechanism as unknown.”</p>
</blockquote>
<blockquote class="blockquote">
<p>“The statistical community has been committed to the almost exclusive use of data models. This commitment has led to irrelevant theory, questionable conclusions, and has kept statisticians from working on a large range of interesting current problems.”</p>
</blockquote>
<blockquote class="blockquote">
<p>“Algorithmic modeling, both in theory and practice, has developed rapidly in fields outside statistics. It can be used both on large complex data sets and as a more accurate and informative alternative to data modeling on smaller data sets. If our goal as a field is to use data to solve problems, then we need to move away from exclusive dependence on data models and adopt a more diverse set of tools.”</p>
</blockquote>
<!-- TODO: Discuss how tree models and deep learning models belong to the black box cuture -->
<p>Statistical prediction problems are of great practical and theoretical interest. The deep learning predictor has a number of advantages over traditional predictors, including that</p>
<ul>
<li>input data can include all data of possible relevance to the prediction problem at hand</li>
<li>nonlinearities and complex interactions among input data are accounted for seamlessly</li>
<li>overfitting is more easily avoided than traditional high dimensional procedures</li>
<li>there exists fast, scale computational frameworks (TensorFlow)</li>
</ul>
<!-- TODO: Discuss interpretability of tree models and deep learning models and trade-off between intepretability and accuracy. Talk about modern approaches to interpretability. -->
</section>
</section>
<section id="what-makes-a-good-predictive-model" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="what-makes-a-good-predictive-model"><span class="header-section-number">1.2</span> What makes a good predictive model?</h2>
<p>What makes a good model? If the goal is prediction, then the model is as good as its prediction. The easiest way to visualize the quality of the prediction is to plot <span class="math inline">\(y\)</span> vs <span class="math inline">\(\hat y\)</span>. Most of the times we are to use empirical assesment of model’s quality. However, sometimes theoretical bounds can be derived for a model that describe it acuracy. For example, in the case of the linear regression model, the prediction interval is defined by <span class="math display">\[
\hat y \pm s\sqrt{1+\frac{1}{n}+\frac{(x-\bar x)^2}{\sum_{i=1}^n(x_i-\bar x)^2}}
\]</span> where <span class="math inline">\(s\)</span> is the standard deviation of the residuals. The prediction interval is the confidence interval for the prediction. The prediction interval is wider than the confidence interval because it includes the uncertainty in the prediction.</p>
<p>Assume we have predictive model <span class="math display">\[
y = f(x) + \epsilon
\]</span> and we have some modeling assumption regarding the distribution of <span class="math inline">\(\epsilon\)</span>. For example, when we use linrar regrssion or BART, we assume that <span class="math inline">\(\epsilon\)</span> follows normal distribution. One simple approach to test if observed samples <span class="math inline">\(\epsilon_1,\ldots,\epsilon_n\)</span> follow a specific distribution is to use an <strong>Exploratory Data Analysis (EDA)</strong>.</p>
<p>The two most common tools for exploratory data analysis are Q-Q plot, scatter plots and bar plots/histograms.</p>
<p>A Q-Q plot simply compares the quantiles of your data with the quantiles of a theoretical distribution (like normal, exponential, etc.). Quantile is the fraction (or percent) of points below the given value. That is, the <span class="math inline">\(i\)</span>-th quantile is the point <span class="math inline">\(x\)</span> for which <span class="math inline">\(i\)</span>% of the data lies below <span class="math inline">\(x\)</span>. On a Q-Q plot, if the two data sets come from a population with the same distribution, we should see the points forming a line that’s roughly straight. More precisely, if the two data sets <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> come from the same distribution, then the points <span class="math inline">\((x_{(i)}, y_{(i)})\)</span> should lie roughly on the line <span class="math inline">\(y = x\)</span>. If <span class="math inline">\(y\)</span> comes from a distribution that’s linear in <span class="math inline">\(x\)</span>, then the points <span class="math inline">\((x_{(i)}, y_{(i)})\)</span> should lie roughly on a line, but not necessarily on the line <span class="math inline">\(y = x\)</span>.</p>
<div id="exm-qqplot" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.1 (Normal Q-Q plot)</strong></span> <a href="#fig-qqplot" class="quarto-xref">Figure&nbsp;<span>1.1</span></a> shows the normal Q-Q plot for the Data on birth weights of babies born in a Brisbane hospital on December 18, 1997. The data set contains 44 records. A more detailed description of the data set can be found in <a href="https://rdrr.io/cran/UsingR/man/babyboom.html"><code>UsingR manual</code></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>babyboom <span class="ot">=</span> <span class="fu">read.csv</span>(<span class="st">"../data/babyboom.csv"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">qqnorm</span>(babyboom<span class="sc">$</span>wt)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">qqline</span>(babyboom<span class="sc">$</span>wt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-qqplot" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-qqplot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="19-select_files/figure-html/fig-qqplot-1.png" class="img-fluid figure-img" width="576">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-qqplot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.1: Normal Q-Q plot of baby weights
</figcaption>
</figure>
</div>
</div>
</div>
<p>Visually, the answer to answer the question “Are Birth Weights Normally Distributed?” is no. We can see that on the left side of the plot the points are below the line. This indicates that the data is skewed to the left. The data is not normally distributed.</p>
<p>The Q-Q plots look different if we split the data based on the gender</p>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> babyboom <span class="sc">%&gt;%</span> <span class="fu">filter</span>(gender<span class="sc">==</span><span class="st">"girl"</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(wt) </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> babyboom <span class="sc">%&gt;%</span> <span class="fu">filter</span>(gender<span class="sc">==</span><span class="st">"boy"</span>)  <span class="sc">%&gt;%</span> <span class="fu">pull</span>(wt) </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">qqnorm</span>(g); <span class="fu">qqline</span>(g)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">qqnorm</span>(b); <span class="fu">qqline</span>(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="19-select_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="576"></p>
<figcaption>Girls</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="19-select_files/figure-html/unnamed-chunk-1-2.png" class="img-fluid figure-img" width="576"></p>
<figcaption>Boys</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p>Histogram of baby weights by gender</p>
</div>
</div>
</div>
<p>How about the times in hours between births of babies?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>hr <span class="ot">=</span> <span class="fu">ceiling</span>(babyboom<span class="sc">$</span>running.time<span class="sc">/</span><span class="dv">60</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>BirthsByHour <span class="ot">=</span> <span class="fu">tabulate</span>(hr)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of hours with 0, 1, 2, 3, 4 births</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>ObservedCounts <span class="ot">=</span> <span class="fu">table</span>(BirthsByHour) </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Average number of births per hour</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>BirthRate<span class="ot">=</span><span class="fu">sum</span>(BirthsByHour)<span class="sc">/</span><span class="dv">24</span>    </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Expected counts for Poisson distribution</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>ExpectedCounts<span class="ot">=</span><span class="fu">dpois</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">4</span>,BirthRate)<span class="sc">*</span><span class="dv">24</span>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># bind into matrix for plotting</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>ObsExp <span class="ot">&lt;-</span> <span class="fu">rbind</span>(ObservedCounts,ExpectedCounts) </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="fu">barplot</span>(ObsExp,<span class="at">names=</span><span class="dv">0</span><span class="sc">:</span><span class="dv">4</span>, <span class="at">beside=</span><span class="cn">TRUE</span>,<span class="at">legend=</span><span class="fu">c</span>(<span class="st">"Observed"</span>,<span class="st">"Expected"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="19-select_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="576"></p>
</figure>
</div>
</div>
</div>
<p>What about the Q-Q plot?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># birth intervals</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>birthinterval<span class="ot">=</span><span class="fu">diff</span>(babyboom<span class="sc">$</span>running.time) </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> <span class="co"># quantiles of standard exponential distribution (rate=1)   </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>exponential.quantiles <span class="ot">=</span> <span class="fu">qexp</span>(<span class="fu">ppoints</span>(<span class="dv">43</span>)) </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="fu">qqplot</span>(exponential.quantiles, birthinterval)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>lmb<span class="ot">=</span><span class="fu">mean</span>(birthinterval)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(exponential.quantiles,exponential.quantiles<span class="sc">*</span>lmb) <span class="co"># Overlay a line</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="19-select_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="576"></p>
</figure>
</div>
</div>
</div>
<p>Here</p>
<ul>
<li><code>ppoints</code> function computes the sequence of probability points</li>
<li><code>qexp</code> function computes the quantiles of the exponential distribution</li>
<li><code>diff</code> function computes the difference between consecutive elements of a vector</li>
</ul>
</div>
</section>
<section id="out-of-sample-performance" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="out-of-sample-performance"><span class="header-section-number">1.3</span> Out of Sample Performance</h2>
<p>A parametric model that we choose to fit to data is chosen from a family of functions. Then, we use optimization to find the best model from that family. To find the best model from a given family of functions we either minimize empirical loss or maximize the likelihood. Finding an appropriate family of functions is a major problem and is called <strong>model selection</strong> problem. For example, the choice of input variables to be included in the model is part of the model selection process. Model selection involves determining which predictors, interactions, or transformations should be included in the model to achieve the best balance between complexity and predictive accuracy. In practice, we often encounter several models for the same dataset that perform nearly identically, making the selection process challenging.</p>
<p>It is important to note that a good model is not necessarily the one that fits the data perfectly. Overfitting can occur when a model is overly complex, capturing noise rather than the underlying pattern. A good model strikes a balance between fitting the data well and maintaining simplicity to ensure generalizability to new, unseen data. For instance, including too many parameters can lead to a perfect fit when the number of observations equals the number of parameters, but such a model is unlikely to perform well on out-of-sample data.</p>
<p>The goal of model selection is not only to achieve a good fit but also to reduce complexity by excluding unnecessary parameters. This process typically involves selecting a model from a relevant class of functions while keeping in mind the trade-offs between bias, variance, and model complexity. Techniques such as cross-validation, information criteria (e.g., AIC, BIC), and regularization methods are commonly used to guide the model selection process.</p>
<p>The model selection task is sometimes one of the most consuming parts of the data analysis. Unfortunately, there is no single rule to find the best model. One way to think about the model choice problem as yet another optimization problem, with the goal to find best family of functions that describe the data. With a small number of predictors we can do brute force (check all possible models). For example, with <span class="math inline">\(p\)</span> predictors there are <span class="math inline">\(2^p\)</span> possible models with no interactions. Thus, the number of potential family functions is huge even for modest values of <span class="math inline">\(p\)</span>. One cannot consider all transformations and interactions.</p>
<p>Our goal is to build a model that predicts well for out-of-sample data, e.g.&nbsp;the data that was not used for training. Eventually, we are interested in using our models for prediction and thus, the out of sample performance is the most important metric and should be used to choose the final model. In-sample performance is of little interest when predictive model need to be chosen, as one of the winners of Netflix prize put it, “It’s like predicting how much someone will like a movie, having them watch it and tell you how much they really liked it”. The out-of-sample performance is the final judge of the quality of our model. The goal is to use data to find a pattern that we can exploit. The pattern will be “statistical” in its nature. To uncover the pattern we start with a training dataset, denoted by <span class="math display">\[
D = (y_i,x_i)_{i=1}^n
\]</span> and to test the validity of our mode we use out-of-sample testing dataset <span class="math display">\[
D^* = (y_j^*, x_j^*)_{j=1}^m,
\]</span> where <span class="math inline">\(x_i\)</span> is a set of <span class="math inline">\(p\)</span> predictors ans <span class="math inline">\(y_i\)</span> is response variable.</p>
<p>A good predictor will “generalize” well and provide low MSE out-of-sample. These are a number of methods/objective functions that we will use to find, <span class="math inline">\(\hat f\)</span>. In a parameter-based style we will find a black box. There are a number of ways to build our black box model. Our goal is to find the map <span class="math inline">\(f\)</span> that approximates the process that generated the data. For example data could be representing some physical observations and our goal is recover the “laws of nature" that led to those observations. One of the pitfalls is to find a map <span class="math inline">\(f\)</span> that does not generalize. Generalization means that our model actually did learn the”laws of nature" and not just identified patterns presented in training. The lack of generalization of the model is called over-fitting. It can be demonstrated in one dimension by remembering the fact from calculus that any set of <span class="math inline">\(n\)</span> points can be approximated by a polynomial of degree <span class="math inline">\(n\)</span>, e.g we can alway draw a line that connects two points. Thus, in one dimension we can always find a function with zero empirical risk. However, such a function is unlikely to generalize to the observations that were not in our training data. In other words, the empirical risk measure for <span class="math inline">\(D^*\)</span> is likely to be very high. Let us illustrate that in-sample fit can be deceiving.</p>
<div id="exm-hard" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.2 (Hard Function)</strong></span> Say we want to approximate the following function <span class="math display">\[
f(x) = \dfrac{1}{1+25x^2}.
\]</span> This function is simply a ratio of two polynomial functions and we will try to build a liner model to reconstruct this function</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">2</span>,<span class="at">by=</span><span class="fl">0.01</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span><span class="sc">+</span><span class="dv">25</span><span class="sc">*</span>x<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximate with polynomial of degree 1 and 2</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>m1 <span class="ot">=</span> <span class="fu">lm</span>(y<span class="sc">~</span>x)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>m2 <span class="ot">=</span> <span class="fu">lm</span>(y<span class="sc">~</span><span class="fu">poly</span>(x,<span class="dv">2</span>))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximate with polynomial of degree 20 and 5</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>m20 <span class="ot">=</span> <span class="fu">lm</span>(y<span class="sc">~</span><span class="fu">poly</span>(x,<span class="dv">20</span>))</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>m5 <span class="ot">=</span> <span class="fu">lm</span>(y<span class="sc">~</span><span class="fu">poly</span>(x,<span class="dv">5</span>))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">3</span>,<span class="dv">3</span>,<span class="at">by=</span><span class="fl">0.01</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span><span class="sc">+</span><span class="dv">25</span><span class="sc">*</span>x<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x,y,<span class="at">type=</span><span class="st">'l'</span>,<span class="at">col=</span><span class="st">'black'</span>,<span class="at">lwd=</span><span class="dv">2</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,<span class="fu">predict</span>(m1,<span class="fu">list</span>(<span class="at">x=</span>x)),<span class="at">lwd=</span><span class="dv">2</span>, <span class="at">col=</span><span class="dv">1</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,<span class="fu">predict</span>(m2,<span class="fu">poly</span>(x,<span class="dv">2</span>)),<span class="at">lwd=</span><span class="dv">2</span>, <span class="at">col=</span><span class="dv">2</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,<span class="fu">predict</span>(m5,<span class="fu">poly</span>(x,<span class="dv">5</span>)),<span class="at">lwd=</span><span class="dv">2</span>, <span class="at">col=</span><span class="dv">3</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,<span class="fu">predict</span>(m20,<span class="fu">poly</span>(x,<span class="dv">20</span>)),<span class="at">lwd=</span><span class="dv">2</span>, <span class="at">col=</span><span class="dv">4</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="st">"f(x)"</span>,<span class="st">"m1"</span>,<span class="st">"m2"</span>,<span class="st">"m5"</span>,<span class="st">"m20"</span>), <span class="at">col=</span><span class="fu">c</span>(<span class="st">"black"</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>), <span class="at">lty=</span><span class="dv">1</span>, <span class="at">cex=</span><span class="fl">0.8</span>, <span class="at">bty=</span><span class="st">'n'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-rungekutta" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rungekutta-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="19-select_files/figure-html/fig-rungekutta-1.png" class="img-fluid figure-img" width="576">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rungekutta-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.2: Runge-Kutta function
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-rungekutta" class="quarto-xref">Figure&nbsp;<span>1.2</span></a> shows the function itself (black line) on the interval <span class="math inline">\([-3,3]\)</span>. We used observations of <span class="math inline">\(x\)</span> from the interval <span class="math inline">\([-2,2]\)</span> to train the data (solid line) and from <span class="math inline">\([-3,-2) \cup (2,3]\)</span> (dotted line) to test the model and measure the out-of-sample performance. We tried four different linear functions to capture the relations. We see that linear model <span class="math inline">\(\hat y = \beta_0 + \beta_1 x\)</span> is not a good model. However, as we increas the degree of the polynomial to 20, the resulting model <span class="math inline">\(\hat y = \beta_0 + \beta_1x + \beta_2 x^2 +\ldots+\beta_{20}x^{20}\)</span> does fit the training data set quite well, but does very poor job on the test data set. Thus, while in-sample performance is good, the out-of sample performance is unsatisfactory. We should not use the degree 20 polynomial function as a predictive model. In practice in-sample out-of-simple loss or classification rates provide us with a metric for providing horse race between different predictors. It is worth mentioning here there should be a penalty for overly complex rules which fits extremely well in sample but perform poorly on out-of-sample data. As Einstein famous said “model should be simple, but not simpler.”</p>
</div>
<p>To a Bayesian, the solution to these decision problems are rather obvious: compute posterior distributions, and then make decisions by maximizing expected utility, where the posterior distribution is used to calculate the expectations. Classical solutions to these problems are different, and use repeated sampling ideas, whereby the performance of a decision rule is judged on its performance if the same decision problem were repeated infinitely. Thus, the decisions are made based on their population properties. One of the main uses of statistical decision theory is to compare different estimators or hypothesis testing procedures. This theory generates many important findings, most notably that many of the common classical estimators are “bad”,in some sense, and that Bayesian estimators are always “good”.</p>
<p>These results have major implications for empirical work and practical applications, as they provide a guide for forecasting.</p>
</section>
<section id="bias-variance-trade-off" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="bias-variance-trade-off"><span class="header-section-number">1.4</span> Bias-Variance Trade-off</h2>
<p>For any predictive model we seek to achieve best possible results, i.e.&nbsp;smallest MSE or misclassification rate. However, a model performance can be different as data used in one training/validation split may produce results dissimilar to another random split. In addition, a model that performed well on the test set may not produce good results given additional data. Sometimes we observe a situation, when a small change in the data leads to large change in the final estimated model, e.g.&nbsp;parameters of the model. These results exemplify the bias/variance tradeoff, where increasing model bias produces large variance in the final results. Similarly, low bias results in low variance, but can also produce an oversimplification of the final model. While Bias/variance concept is depicted below.</p>
<div id="fig-bias-variance" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bias-variance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./fig//svg/bias-variance.drawio.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bias-variance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.3: Bias-variance trade-off
</figcaption>
</figure>
</div>
<div id="exm-bias-variance" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.3 (Bias-variance)</strong></span> We demonstrate bias-variance concept using Boston housing example. We fit a model <span class="math inline">\(\mathrm{medv} = f(\mathrm{lstat})\)</span>. We use polynomial functions to approximate this relation. We fitted twelve polynomial functions with degree <span class="math inline">\(1,\ldots,12\)</span> ten time. Each time we randomly selected 20% of sample for testing and the rest for training. We estimated in-of-sample performance (bias) and out-of-sample performance by calculating MSE on training and testing sets correspondingly. For each polynomial <span class="math inline">\(f\)</span> we averaged MSE from each of the ten models.</p>
<p><a href="#fig-boston-bias-variance" class="quarto-xref">Figure&nbsp;<span>1.4 (a)</span></a> shows bias and variance for our twelve different models. As expected, bias increases while variance increases as model complexity grows. On the other hand out-of-sample MSE is a U-shaped curve. The optimal model is the one that has smallest out-of-sample MSE. In our case it is polynomial of degree 5!</p>
<div id="fig-boston" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-boston-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-boston" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-boston-bias-variance" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-boston-bias-variance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./fig//svg/boston-bias-variance.svg" class="img-fluid figure-img" data-ref-parent="fig-boston">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-boston-bias-variance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Metrics for twelve polynomial functions fitted into Boston housing data set. As model complexity (degree of the polynomial function) increases, model variance increase and bias decreases. Out-of-sample MSE is smallest for 5th degree polynomial function, which is the optimal model in terms of bias-variance trade-off.
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-boston" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-boston-optimal-model" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-boston-optimal-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./fig//svg/boston-optimal-model.svg" class="img-fluid figure-img" data-ref-parent="fig-boston">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-boston-optimal-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Optimal complexity model, which is 5th degree polynomial used to predict observations from testing data set. Model predictions (red line) are compared to actual observed values of medv variable (dots)
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-boston-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.4: Metrics for 12 models
</figcaption>
</figure>
</div>
<p>Let’s take another, a more formal, look at bias-variance trade-off for a linear regression problem. We are interested in the decomposition of the error <span class="math inline">\(\E{(y-\hat y)^2}\)</span> as a function of bias <span class="math inline">\(\E{y-\hat y}\)</span> and variance <span class="math inline">\(\Var{\hat y}\)</span>.</p>
<p>Here <span class="math inline">\(\hat y = \hat f_{\beta}(x)\)</span> prediction from the model, and <span class="math inline">\(y = f(x) + \epsilon\)</span> is the true value, which is measured with noise <span class="math inline">\(\Var{\epsilon} = \sigma^2\)</span>, <span class="math inline">\(f(x)\)</span> is the true unknown function. The expectation above measures squared error of our model on a random sample <span class="math inline">\(x\)</span>. <span class="math display">\[
\begin{aligned}
\E{(y - \hat{y})^2}
&amp; = \E{y^2 + \hat{y}^2 - 2 y\hat{y}} \\
&amp; = \E{y^2} + \E{\hat{y}^2} - \E{2y\hat{y}} \\
&amp; = \Var{y} + \E{y}^2 + \Var{\hat{y}} + \E{\hat{y}}^2 - 2f\E{\hat{y}} \\
&amp; = \Var{y} + \Var{\hat{y}} + (f^2 - 2f\E{\hat{y}} + \E{\hat{y}}^2) \\
&amp; = \Var{y} + \Var{\hat{y}} + (f - \E{\hat{y}})^2 \\
&amp; = \sigma^2 + \Var{\hat{y}} + \mathrm{Bias}(\hat{y})^2\end{aligned}
\]</span> Here we used the following identity: <span class="math inline">\(\Var{X} = \E{X^2} - \E{X}^2\)</span> and the fact that <span class="math inline">\(f\)</span> is deterministic and <span class="math inline">\(\E{\epsilon} = 0\)</span>, thus <span class="math inline">\(\E{y} = \E{f(x)+\epsilon} = f + \E{\epsilon} = f\)</span>.</p>
</div>
</section>
<section id="cross-validation" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="cross-validation"><span class="header-section-number">1.5</span> Cross-Validation</h2>
<p>If the data set at-hand is small and we cannot dedicate large enough sample size for testing, simply measuring error on test data set can lead to wrong conclusions. When size of the testing set <span class="math inline">\(D^*\)</span> is small, the estimated out-of-sample performance is of high variance, depending on precisely which observations are included in the test set. On the other hand, when training set <span class="math inline">\(D^*\)</span> is a large fraction of the entire sample available, estimated out-of-sample performance will be underestimated. Why?</p>
<p>A trivial solution is to perform the training/testing split randomly several times and then use average out-of-sample errors. This procedure has two parameters, the fraction of samples to be selected for testing <span class="math inline">\(p\)</span> and number of estimates to be performed <span class="math inline">\(K\)</span>. The resulting algorithm is as follows</p>
<pre><code>fsz = as.integer(p*n)
error = rep(0,K)
for (k in 1:K)
{
    test_ind = sample(1:n,size = fsz)
    training = d[-test_ind,]
    testing  = d[test_ind,]
    m = lm(y~x, data=training)
    yhat = predict(m,newdata = testing)
    error[k] = mean((yhat-testing$y)^2)
}
res = mean(error)</code></pre>
<p><a href="#fig-bootstrap" class="quarto-xref">Figure&nbsp;<span>1.5</span></a> shows the process of splitting data set randomly five times.</p>
<p>Cross validation modifies the random splitting approach uses more “disciplined” way to split data set for training and testing. Instead of randomly selecting training data points, CV chooses consecutive observations and thus, each data point is used once for testing. As the random approach, CV helps addressing the high variance issue of out-of-sample performance estimation when data set available is small. <a href="#fig-cv" class="quarto-xref">Figure&nbsp;<span>1.6</span></a> shows the process of splitting data set five times using cross-validation approach.</p>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-bootstrap" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bootstrap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./fig//svg/bag5-excel.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bootstrap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.5: Bootstrap
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-cv" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cv-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./fig//svg/cv5-excel.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cv-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.6: Cross-validation
</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p>Training set (red) and testing set (green)</p>
</div>
</div>
</div>
<div id="exm-simulated" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.4 (Simulated)</strong></span> We use simulated data set to demonstrate difference between estimated out-of-sample performance using random 20/80 split, 5-fold cross-validation and random split. We used <span class="math inline">\(x=-2,-1.99,-1.98,\ldots,2\)</span> and <span class="math inline">\(y = 2+3x + \epsilon, ~ \epsilon \sim N(0,\sqrt{3})\)</span>. We simulated 35 datasets of size 100. For each of the simulated data sets, we fitted a linear model and estimated out-of-sample performance using three different approaches. <a href="#fig-test-error20" class="quarto-xref">Figure&nbsp;<span>1.7</span></a> compares empirical distribution of errors estimated from 35 samples.</p>
<div id="fig-test-error20" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-test-error20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./fig//svg/test-error20.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-test-error20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.7: Empirical comparison of simple split, cross-validation, and bootstrap approaches to estimate out-of sample performance.
</figcaption>
</figure>
</div>
<p>As we can see the estimated out-of-sample performance by a training set approach is of high variance. While, both cross-validation and bootstrap approaches lead to better estimates, they require model to be fitted 5 times, which can be computationally costly for a complex model. On the other hand, estimate from cross-validation is of lower variance and less bias compared to the bootstrap estimate. Thus, we should prefer cross-validation.</p>
</div>
</section>
<section id="bayesian-model-selection" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="bayesian-model-selection"><span class="header-section-number">1.6</span> Bayesian Model Selection</h2>
<p>The probabilistic models of interest are the joint probability distribution <span class="math inline">\(p(D,\theta)\)</span> (called a generative model) and <span class="math inline">\(P(Y,\theta \mid X)\)</span> (discriminative model). Discriminative models are easier to build and are more frequently used in practice. Generative model requires modeling a distribution over the set of observed variables, which makes our model more complicated. Text analysis provides an illustrative example. The task of identifying a topic of an article can be solved using discriminative distribution. The problem of generating a new article requires generative model.</p>
<p>Let <span class="math inline">\(D\)</span> denote data. Let <span class="math inline">\(\theta_M \in \Theta_M\)</span> denote a set of parameters under model <span class="math inline">\(M \in \mathcal{M}\)</span>. Let <span class="math inline">\(\theta_M = (\theta_1, \ldots, \theta_p)\)</span> be the <span class="math inline">\(p\)</span>-vector of parameters. The Bayesian approach is straightforward: implement the Bayesian paradigm by executing Bayes rule. This requires the laws of probability and not optimization techniques. The notion of model complexity is no different. Let <span class="math inline">\(\mathcal{M}\)</span> denote the space of models and <span class="math inline">\(\theta\)</span> be the parameter vector. The Bayesian paradigm simply places probabilities over parameters and models given the data, namely <span class="math inline">\(p(\theta_M, M | y)\)</span>, where <span class="math inline">\(y = (y_1, \ldots, y_n)\)</span>. This has a number of decompositions. Bayes theorem calculates the joint posterior over parameters and models given data <span class="math inline">\(D\)</span>, namely <span class="math display">\[
    P(\theta_M,M\mid D) = P(\theta_M \mid M,D)P(M\mid D).
\]</span> Notice how this factors the posterior into two terms: the conditional posterior over parameters given the model and the posterior over models given data.</p>
<p>The key quantity is the weight of <strong>evidence</strong> (a.k.a. marginal distribution of the data <span class="math inline">\(D\)</span> given the model <span class="math inline">\(M\)</span>), defined by <span class="math display">\[
p( D | M ) = \int_{ \Theta_M } p( D \mid \theta_M , M )  p ( \theta_M | M ) d \theta_M.
\]</span> Here <span class="math inline">\(p( D \mid \theta_M , M )\)</span> is the traditional likelihood function. The key conditional distribution, however, is the specification of the prior over parameters <span class="math inline">\(p(\theta_M | M)\)</span>. As this is used in the marginalization, it can affect the Bayes risk dramatically. Occam’s razor comes from the fact that this marginalization provides a weight of evidence that favors simpler models over more complex ones.</p>
<p>This leads to a posterior over models, which is calculated as: <span class="math display">\[\begin{align*}
    P(M\mid D)  &amp; = \dfrac{P(D\mid M)P(M)}{P(D)}, \\
    P(D\mid M ) &amp; = \int_{ \Theta_M} P(D\mid \theta_M , M ) p( \theta_M | M ) d \theta_M.
\end{align*}\]</span> Notice that this requires a joint prior specification <span class="math inline">\(p(\theta_M, M) = p(\theta_M | M)p(M)\)</span> over parameters and models. The quantity <span class="math inline">\(p(M| D)\)</span> is the marginal posterior for model complexity given the data. There is an equivalent posterior <span class="math inline">\(p(\theta_M | D)\)</span> for the parameters. <span class="math inline">\(p(D \mid M)\)</span> is the evidence of the data <span class="math inline">\(D\)</span> given the complexity (a.k.a. conditional likelihood). The full evidence is <span class="math display">\[
p( D ) = \int p( D| M ) p(M) d M.
\]</span> This has been used to select the amount of hyperparameter regularization; see, for example,<span class="citation" data-cites="mackay1992bayesian">MacKay (<a href="references.html#ref-mackay1992bayesian" role="doc-biblioref">1992</a>)</span>.</p>
<p>We will see that the prior <span class="math inline">\(p(\theta_M | M)\)</span> will lead to an Occam’s razor effect, namely that the marginal distribution will favor simpler models. Importantly, this Occam’s razor effect is not in conflict with the Bayesian double descent phenomenon, which emerges from the marginal posterior of models given data and the conditional prior specification <span class="math inline">\(p(\theta_M | M)\)</span>.</p>
<div id="exm-dice-example" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.5 (Dice Example)</strong></span> Let’s consider a simple example of throwing a dice. Say, there are three dices, one that has numbers 1 through 6 (regular dice), one with three sides with ones and three sides with 2s (dice 1-2), one with three sides with ones and three sides with 2s and three sides with 3s (dice 1-2-3).</p>
<div class="quarto-layout-panel" data-layout-ncol="3">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig/dice-1-2.png" class="img-fluid figure-img" style="width:30.0%"></p>
<figcaption>Dice 1-2</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig/dice-1-2-3.png" class="img-fluid figure-img" style="width:30.0%"></p>
<figcaption>Dice 1-2-3</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="fig/dice-regular.png" class="img-fluid figure-img" style="width:30.0%"></p>
<figcaption>Regular Dice</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>You observe outcome of one dice throw and it is 3. Which dice is it?</p>
<p>Two out of three explanations are plausible (dice 1-2-3 and regular dice). Intuitively, the 1-2-3 dice is more likely to produce 3 than the regular dice. Thus, if we need to choose, we would choose the 1-2-3 dice. For the sake of completeness, we can use the Bayes rule to calculate the evidence for each model.</p>
<p>Using Bayes’ rule: <span class="math display">\[P(M_i | D) = \frac{P(D | M_i) P(M_i)}{P(D)}\]</span></p>
<p>where <span class="math inline">\(M_i\)</span> represents each dice model and <span class="math inline">\(D\)</span> is the observed data (outcome = 3).</p>
<p>We equal prior probabilities for each dice: <span class="math display">\[P(M_1) = P(M_2) = P(M_3) = \frac{1}{3}.\]</span> Now, we calculate the likelihood for each model.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr class="header">
<th>Dice Type</th>
<th>Probability of Rolling a 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Regular dice (<span class="math inline">\(M_1\)</span>)</td>
<td><span class="math inline">\(P(3 | M_1) = \frac{1}{6}\)</span></td>
</tr>
<tr class="even">
<td>Dice 1-2 (<span class="math inline">\(M_2\)</span>)</td>
<td><span class="math inline">\(P(3 | M_2) = 0\)</span> (impossible since this dice only has 1s and 2s)</td>
</tr>
<tr class="odd">
<td>Dice 1-2-3 (<span class="math inline">\(M_3\)</span>)</td>
<td><span class="math inline">\(P(3 | M_3) = \frac{1}{3}\)</span> (2 out of 6 sides show 3)</td>
</tr>
</tbody>
</table>
<p>Then, the marginal likelihood is: <span class="math display">\[P(D) = \sum_{i=1}^{3} P(D | M_i) P(M_i) = \frac{1}{6} \cdot \frac{1}{3} + 0 \cdot \frac{1}{3} + \frac{1}{3} \cdot \frac{1}{3} = \frac{1}{6}.\]</span></p>
<p>Finally, posterior probabilities are</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 64%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Dice Type</th>
<th>Posterior Probability Calculation</th>
<th>Posterior Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Regular dice</td>
<td><span class="math inline">\(P(M_1 | D) = \frac{\frac{1}{6} \cdot \frac{1}{3}}{\frac{1}{6}}\)</span></td>
<td><span class="math inline">\(\frac{1}{3}\)</span> (33.3%)</td>
</tr>
<tr class="even">
<td>Dice 1-2</td>
<td><span class="math inline">\(P(M_2 | D) = \frac{0 \cdot \frac{1}{3}}{\frac{1}{6}}\)</span></td>
<td><span class="math inline">\(0\)</span> (0%)</td>
</tr>
<tr class="odd">
<td>Dice 1-2-3</td>
<td><span class="math inline">\(P(M_3 | D) = \frac{\frac{1}{3} \cdot \frac{1}{3}}{\frac{1}{6}}\)</span></td>
<td><span class="math inline">\(\frac{2}{3}\)</span> (66.7%)</td>
</tr>
</tbody>
</table>
<p>Given the observation of outcome 3, the dice 1-2-3 is twice as likely as the regular dice. The dice 1-2 is completely ruled out since it cannot produce a 3. This demonstrates how Bayesian model selection naturally eliminates impossible explanations and provides relative evidence for competing hypotheses.</p>
</div>
<p>This example demonstrates how the Bayesian paradigm provides a coherent framework to simultaneously infer parameters and model complexity. The fact that Bayesian model selects simplest possible explanation for the observed data, is called the automatic Occam’s razor. The Occam’s razor is a principle that states that the simplest explanation is the best explanation.</p>
<p>While performing data analysis using learning algorithms, we perform two tasks, namely training and inference which are summarized in the table below</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Step</th>
<th style="text-align: left;">Given</th>
<th style="text-align: left;">Hidden</th>
<th style="text-align: left;">What to find</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Training</td>
<td style="text-align: left;"><span class="math inline">\(D = (X,Y) = \{x_i,y_i\}_{i=1}^n\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\theta\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p(\theta \mid D)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">Prediction</td>
<td style="text-align: left;"><span class="math inline">\(x_{\text{new}}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(y_{\text{new}}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p(y_{\text{new}}  \mid  x_{\text{new}}, D)\)</span></td>
</tr>
</tbody>
</table>
<p>The training can be performed via the Bayes rule <span class="math display">\[
p(\theta \mid D) = \dfrac{p(Y \mid \theta,X)p(\theta)}{\int p(Y \mid \theta,X)p(\theta)d\theta}.
\]</span> Now to perform the second step (prediction), we calculate <span class="math display">\[
p(y_{\text{new}}  \mid  x_{\text{new}}, D) = \int p(y_{\text{new}}  \mid  x_{\text{new}},\theta)p(\theta \mid D)d\theta
\]</span> Thus, full Bayesian inference requires calculating two integrals, which might be difficult. We mentioned earlier that MAP allows us to avoid those calculations by approximating the posterior with <span class="math display">\[
p(\theta \mid D) \approx \delta(\theta_{\text{MAP}}),~~\theta_{\text{MAP}} \in \argmax_{\theta}p(\theta \mid D)
\]</span> To calculate <span class="math inline">\(\theta_{\text{MAP}}\)</span>, we do not need to know the normalizing constant for calculating posterior, since the solution of optimization problem does not depend on this constant. Further, the second integral for inference becomes degenerate and get approximated by <span class="math display">\[
p(y_{\text{new}}  \mid  x_{\text{new}}, D) = \int p(y_{\text{new}}  \mid  x_{\text{new}},\theta)p(\theta \mid D)d\theta \approx p(y_{\text{new}}  \mid  x_{\text{new}},\theta_{\text{MAP}}).
\]</span></p>
<p>The <a href="#fig-bayes-model-selection" class="quarto-xref">Figure&nbsp;<span>1.8</span></a> below illustrates the Bayesian model selection process. The figure shows the joint distribution over parameters and data for three models. You can think of each ellipse as the region where most of the probability mass is concentrated.</p>
<div id="fig-bayes-model-selection" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bayes-model-selection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="fig/bayes-model-selection.drawio.svg" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bayes-model-selection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.8: Bayesian model Selection
</figcaption>
</figure>
</div>
<p>If we project the ellipses onto the parameter space, we get the prior distributions for each model. We can see that the <span class="math inline">\(M_2\)</span> is the most concentrated. If we project the ellipses onto the data space, we get the prior distributions over data for each model.</p>
<p>After observing data <span class="math inline">\(D\)</span> (horizontal line), each prior gets updated. The intersection of the observed data line with each ellipse shows how well each model can explain the data. Models with good overlap between prior and observed data will have higher posterior probability. <span class="math inline">\(M_3\)</span> appears to have the best intersection with the observed data, it is the model with the highest marginal likelihood.</p>
<p>This illustrates how Bayesian model selection naturally favors models that achieve the best balance between explaining the observed data and maintaining appropriate complexity, automatically implementing Occam’s razor through the evidence calculation.</p>
<div id="exm-racial" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.6 (Racial discrimination)</strong></span> Say we want to analyze racial discrimination by the US courts. We have three variables:</p>
<ul>
<li>Murderer: <span class="math inline">\(m \in {0,1}\)</span> (black/white)</li>
<li>Victim: <span class="math inline">\(v \in \{0,1\}\)</span> (black/white)</li>
<li>Verdict: <span class="math inline">\(d \in \{0,1\}\)</span> (prison/death penalty)</li>
</ul>
<p>Say we have the data</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">m</th>
<th style="text-align: center;">v</th>
<th style="text-align: center;">d</th>
<th style="text-align: center;">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">132</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">19</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">52</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">97</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<p>We would like to establish a causal relations between the race and verdict variables. For this, we consider several models</p>
<ol type="1">
<li><p><span class="math inline">\(p(d \mid m,v) = p(d) = \theta\)</span></p></li>
<li><p><span class="math inline">\(p(d \mid m,v) = p(d \mid v)\)</span>; <span class="math inline">\(p(d \mid v=0) = \alpha, ~p(d \mid v=1)=\beta\)</span></p></li>
<li><p><span class="math inline">\(p(d \mid v,m) = p(d \mid m)\)</span>; <span class="math inline">\(p(d \mid m=1) = \gamma,~p(d \mid m=1) = \delta\)</span></p></li>
<li><p><span class="math inline">\(p(d|v,m)\)</span> cannot be reduced, and<br>
</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(p(d=1 \mid m,v)\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=0\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=1\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(v=0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\tau\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\chi\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(v=1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\nu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td>
</tr>
</tbody>
</table></li>
</ol>
<p>We calculate which model describes data the best, we calculate the evidences. We need to describe the discriminative model <span class="math display">\[
p(Y ,\theta \mid X) = p(Y \mid X,\theta)p(\theta \mid X)
\]</span> Here <span class="math inline">\(X\)</span> is the number of cases, and <span class="math inline">\(Y\)</span> is the number of death penalties. We use uninformative prior <span class="math inline">\(\theta \sim U[0,1]\)</span>. To specify the likelihood, we use Binomial distribution <span class="math display">\[
Y \mid X,\theta \sim B(X,\theta),~~B(Y \mid X,\theta) = C_Y^Xp^Y(1-\theta)^{X-Y}
\]</span> We assume <span class="math inline">\(p(\theta)\sim Uniform\)</span>. Now lets calculate the evidence <span class="math display">\[
p(Y, \theta \mid X) = \int p(Y  \mid  X,\theta)p(\theta)d\theta
\]</span> for each of the four models</p>
<ol type="1">
<li><span class="math inline">\(p(Y \mid X) = \int B(19 \mid 151,\theta)B(0 \mid 9,\theta)B(11 \mid 63,\theta)B(6 \mid 103,\theta)d\theta\)</span> <span class="math inline">\(\propto \int_0^{1} \theta^{36}(1-\theta)^{290}d\theta = B(37,291) = 2.8\times 10^{-51}\)</span></li>
<li><span class="math inline">\(p(Y \mid X) = \int\int B(19 \mid 151,\alpha)B(0 \mid 9,\beta)B(11 \mid 63,\alpha)B(6 \mid 103,\beta)d\alpha d\beta \propto 4.7\times 10^{-51}\)</span></li>
<li><span class="math inline">\(p(d \mid v,m) = p(d \mid m)=\int\int B(19 \mid 151,\gamma)B(0 \mid 9,\gamma)B(11 \mid 63,\delta)B(6 \mid 103,\delta)d\gamma d\delta \propto 0.27\times10^{-51}\)</span></li>
<li><span class="math inline">\(p(d \mid v,m) = \int\int\int\int B(19 \mid 151,\tau)B(0 \mid 9,\nu)B(11 \mid 63,\chi)B(6 \mid 103,\zeta)d\tau d\nu d\chi d\zeta \propto 0.18\times10^{-51}\)</span></li>
</ol>
<p>The last model is too complex, it can explain any relations in the data and this, has the lowest evidence score! However, if we are to use ML estimates, the fourth model will have the highest likelihood. Bayesian approach allows to avoid over-fitting! You can also see that this data set contains the Simpson’s paradox. Check it! A related problem is Bertrand’s gold box problem.</p>
</div>
<section id="the-bayesian-information-criterion" class="level3" data-number="1.6.1">
<h3 data-number="1.6.1" class="anchored" data-anchor-id="the-bayesian-information-criterion"><span class="header-section-number">1.6.1</span> The Bayesian Information Criterion</h3>
<p>The Bayesian Information Criterion (BIC) is a model selection criterion that penalizes the complexity of the model. It is derived from a Bayesian approach. The BIC is defined as:</p>
<p><span class="math display">\[
\mathrm{BIC} =  \log P(D\mid \hat{\theta}_k, M_k) - \frac{k}{2} \log n.
\]</span></p>
<p>Here <span class="math inline">\(\hat{\theta}_k\)</span> is the MAP estimate of the <span class="math inline">\(k\)</span> parameters in model <span class="math inline">\(M_k\)</span>, and <span class="math inline">\(n\)</span> is the sample size. As such, there is a penalty <span class="math inline">\(-\frac{k}{2} \log n\)</span> for increasing the dimensionality <span class="math inline">\(k\)</span> of the model under consideration.</p>
<p>BIC uses the marginal likelihood of the data under model <span class="math inline">\(M_k\)</span> (denoted <span class="math inline">\(M\)</span> for simplicity here) is approximated using Laplace’s method.</p>
<p>The idea of Laplace’s method is to approximate integrals of the form <span class="math inline">\(\int f(\theta) e^{-g(\theta)} d\theta\)</span> where <span class="math inline">\(g(\theta)\)</span> has a sharp minimum at some point <span class="math inline">\(\hat{\theta}\)</span>. The method works by approximating <span class="math inline">\(g(\theta)\)</span> with its second-order Taylor expansion around the minimum <span class="math inline">\(\hat{\theta}\)</span>:</p>
<p><span class="math display">\[
g(\theta) \approx g(\hat{\theta}) + \frac{1}{2}g''(\hat{\theta})(\theta-\hat{\theta})^2
\]</span></p>
<p>since <span class="math inline">\(g'(\hat{\theta}) = 0\)</span> at the minimum. This transforms the integral into a Gaussian form:</p>
<p><span class="math display">\[
\int f(\theta) e^{-g(\theta)} d\theta \approx f(\hat{\theta}) e^{-g(\hat{\theta})} \int e^{-\frac{1}{2}g''(\hat{\theta})(\theta-\hat{\theta})^2} d\theta
\]</span></p>
<p>The remaining integral is a standard Gaussian integral that evaluates to <span class="math inline">\(\sqrt{\frac{2\pi}{g''(\hat{\theta})}}\)</span>, giving us:</p>
<p><span class="math display">\[
\int f(\theta) e^{-g(\theta)} d\theta \approx f(\hat{\theta}) e^{-g(\hat{\theta})} \sqrt{\frac{2\pi}{g''(\hat{\theta})}}
\]</span>.</p>
<p>In the multivariate case, we have <span class="math inline">\(\theta \in \mathbb{R}^k\)</span> is a <span class="math inline">\(k\)</span>-dimensional parameter vector. The second-order Taylor expansion around the minimum <span class="math inline">\(\hat{\theta}\)</span> becomes:</p>
<p><span class="math display">\[
g(\theta) \approx g(\hat{\theta}) + \frac{1}{2}(\theta-\hat{\theta})^T \mathbf{H}(\hat{\theta}) (\theta-\hat{\theta})
\]</span></p>
<p>where <span class="math inline">\(\mathbf{H}(\hat{\theta})\)</span> is the <span class="math inline">\(k \times k\)</span> Hessian matrix of second derivatives at <span class="math inline">\(\hat{\theta}\)</span>. The multivariate Gaussian integral then evaluates to:</p>
<p><span class="math display">\[
\int f(\theta) e^{-g(\theta)} d\theta \approx f(\hat{\theta}) e^{-g(\hat{\theta})} (2\pi)^{k/2} |\det(\mathbf{H}(\hat{\theta}))|^{-\frac{1}{2}}
\]</span></p>
<p>In the context of Bayesian model selection, we apply this to approximate the marginal likelihood (evidence). We have:</p>
<p><span class="math display">\[P(D\mid M) = \int P(D\mid \theta,M)P(\theta\mid M)d\theta\]</span></p>
<p>Taking the logarithm and identifying <span class="math inline">\(g(\theta) = -\log P(D\mid \theta,M)P(\theta\mid M)\)</span>, the maximum a posteriori (MAP) estimate <span class="math inline">\(\hat{\theta}\)</span> corresponds to the minimum of <span class="math inline">\(g(\theta)\)</span>. The second derivative (Hessian) <span class="math inline">\(\mathbf{H}(\hat{\theta})\)</span> at this point determines the curvature of the log-posterior.</p>
<p><span class="math display">\[
P(D\mid M) = \int P(D\mid \theta,M)P(\theta\mid M)d\theta \approx P(D\mid \hat{\theta},M)P(\hat{\theta}\mid M) (2 \pi)^{k/2} |\det(\mathbf{H}(\hat{\theta}))|^{-\frac{1}{2}}.
\]</span></p>
<p>Here <span class="math inline">\(\hat{\theta}\)</span> is the posterior mode (MAP estimate), and <span class="math inline">\(\mathbf{H}(\hat{\theta})\)</span> is the negative Hessian of the log-posterior at the mode. Taking the logarithm, and assuming <span class="math inline">\(P(\hat{\theta}|M)\)</span> and Hessian terms are <span class="math inline">\(O_p(1)\)</span> or scale appropriately with <span class="math inline">\(n\)</span> (this assumption is justified because as <span class="math inline">\(n\)</span> increases, the likelihood dominates the prior, making the prior term negligible relative to the <span class="math inline">\(O(\log n)\)</span> likelihood term, while the Hessian determinant typically grows polynomially in <span class="math inline">\(n\)</span>, contributing at most <span class="math inline">\(O(\log n)\)</span> terms that are absorbed into the approximation), we get:</p>
<p><span class="math display">\[
\log P(D\mid M) \approx \log P(D\mid \hat{\theta},M) - \dfrac{k}{2}\log n,
\]</span></p>
<p>which is proportional to the BIC. (Note: The exact definition and derivation of BIC can vary slightly, but this captures the essence). The BIC approximation shows how the Bayesian approach naturally penalizes model complexity through the dimensionality term <span class="math inline">\(-\frac{k}{2}\log n\)</span>.</p>
<p>The Bayesian approach averages over the posterior distribution of models given data. Suppose that we have a finite list of models <span class="math inline">\(M \in \{M_1, \ldots, M_J\}\)</span>. Then we can calculate the posterior over models as:</p>
<p><span class="math display">\[
p(M_j | y) = \frac{p(y | M_j) p(M_j)}{\sum_{i=1}^J p(y | M_i) p(M_i)}, \quad {\rm where} \; p(y | M_j) = \int L_j(\theta_j|y) p(\theta_j | M_j) d\theta_j.
\]</span></p>
<p>Laplace’s approximation provides a simple <span class="citation" data-cites="lindley1961use">(<a href="references.html#ref-lindley1961use" role="doc-biblioref">Lindley 1961</a>)</span> illustration of how dimensionality is weighted in the Bayesian paradigm. Hence, BIC is related to a log-posterior approximation. Hence, if prior model probabilities <span class="math inline">\(P(M_j)\)</span> are uniform, then <span class="math inline">\(P(M_j\mid D) \propto P(D \mid M_j) \approx \exp(\mathrm{BIC}_j)\)</span>.</p>
<p>In a more general case, the evidence (a.k.a. marginal likelihood) for hypotheses (a.k.a. models) <span class="math inline">\(M_i\)</span> is calculated as follows:</p>
<p><span class="math display">\[
P(D\mid M_i) = \int P(D\mid \theta, M_i)P(\theta\mid M_i)d\theta.
\]</span></p>
<p>Laplace approximation, in the one-dimensional case (<span class="math inline">\(k=1\)</span>), yields:</p>
<p><span class="math display">\[
P(D\mid M_i) \approx P(D\mid \hat{\theta}, M_i)P(\hat{\theta}\mid M_i)\sqrt{2\pi}\sigma_{\text{post}}.
\]</span></p>
<p>Here <span class="math inline">\(\hat{\theta}\)</span> is the maximum (MAP) estimate of the parameter and <span class="math inline">\(\sigma_{\text{post}} = (-H(\hat{\theta}))^{-1/2}\)</span> where <span class="math inline">\(H(\hat{\theta})\)</span> is the second derivative of the log-posterior at <span class="math inline">\(\hat{\theta}\)</span>.</p>
<p>Generally, in the <span class="math inline">\(k\)</span>-dimensional case, we have:</p>
<p><span class="math display">\[
P(D\mid M_i) \approx P(D\mid \hat{\theta}, M_i)P(\hat{\theta}\mid M_i) (2\pi)^{k/2} |\det(-\mathbf{H}(\hat{\theta}))|^{-\frac{1}{2}}.
\]</span></p>
<p>Here <span class="math inline">\(\mathbf{H}(\hat{\theta}) = \nabla^2\log (P(D\mid \hat{\theta}, M_i)P(\hat{\theta}\mid M_i))\)</span> is the Hessian of the log-posterior function evaluated at the mode <span class="math inline">\(\hat{\theta}\)</span>. As the amount of data collected increases, this Gaussian approximation is expected to become increasingly accurate.</p>
<p>Mackay <span class="citation" data-cites="mackay1992bayesian">(<a href="references.html#ref-mackay1992bayesian" role="doc-biblioref">MacKay 1992</a>)</span> proposes the NIC criterion for selection of neural networks.</p>
</section>
<section id="nic-and-evidence-framework" class="level3" data-number="1.6.2">
<h3 data-number="1.6.2" class="anchored" data-anchor-id="nic-and-evidence-framework"><span class="header-section-number">1.6.2</span> NIC and evidence framework</h3>
<p>David MacKay’s Neural Information Criterion (NIC) and the associated evidence framework represent pioneering efforts to apply Bayesian model selection principles to neural networks. This framework addresses the fundamental challenge of selecting appropriate network architectures and hyperparameters by computing approximations to the marginal likelihood, or model evidence, for different neural network configurations.</p>
<p>The evidence framework builds upon the Laplace approximation to estimate the marginal likelihood of neural network models. Given a neural network with parameters <span class="math inline">\(\theta\)</span> and hyperparameters <span class="math inline">\(\alpha\)</span> (such as weight decay parameters), the evidence for a particular model configuration is:</p>
<p><span class="math display">\[
P(D|M,\alpha) = \int P(D|\theta,M) P(\theta|M,\alpha) d\theta
\]</span></p>
<p>where <span class="math inline">\(D\)</span> represents the training data, <span class="math inline">\(M\)</span> denotes the model architecture, and <span class="math inline">\(P(\theta|M,\alpha)\)</span> is the prior distribution over network weights. The Laplace approximation evaluates this integral by expanding the log-posterior around its mode <span class="math inline">\(\theta^*\)</span>, yielding:</p>
<p><span class="math display">\[
\log P(D|M,\alpha) \approx \log P(D|\theta^*,M) + \log P(\theta^*|M,\alpha) - \frac{1}{2}\log|H|
\]</span></p>
<p>where <span class="math inline">\(H\)</span> is the Hessian of the negative log-posterior at the mode <span class="math inline">\(\theta^*\)</span>. This approximation transforms the intractable integral into a computation involving the maximum a posteriori (MAP) estimate and the curvature of the posterior at that point.</p>
<p>The evidence framework provides a principled approach to several critical decisions in neural network design. For hyperparameter selection, the framework automatically determines optimal regularization strengths by maximizing the evidence with respect to hyperparameters such as weight decay coefficients. Rather than relying on cross-validation, which can be computationally expensive and may not capture the full uncertainty in hyperparameter selection, the evidence provides a direct measure of how well different hyperparameter values support the observed data.</p>
<p>Architecture comparison becomes feasible through direct evidence computation for different network structures. The framework can compare networks with different numbers of hidden units, layers, or connectivity patterns by evaluating their respective marginal likelihoods. This comparison naturally incorporates Occam’s razor, as more complex architectures are penalized through the integration over their larger parameter spaces, unless the additional complexity is justified by substantially improved fit to the data.</p>
<p>The Hessian computation required for the Laplace approximation presents significant computational challenges for modern deep networks with millions or billions of parameters. The full Hessian matrix would be prohibitively large to compute and store explicitly. MacKay’s original framework addressed this through various approximation strategies, including the use of automatic relevance determination (ARD) priors that allow the network to effectively prune irrelevant connections by driving their associated precision parameters to infinity.</p>
<p>Modern adaptations of the evidence framework have developed sophisticated methods to handle the computational challenges of contemporary deep learning. Linearized variants approximate the neural network through its first-order Taylor expansion around the MAP estimate, reducing the complexity of Hessian computations while maintaining reasonable approximation quality. These linearized approaches are particularly effective for networks that are sufficiently wide or when the posterior is approximately Gaussian.</p>
<p>Kronecker-structured approximations represent another significant advancement, exploiting the structure of neural network computations to factorize the Hessian matrix into more manageable components. By recognizing that gradients in neural networks can be expressed as Kronecker products of activations and error signals, these methods achieve substantial computational savings while preserving much of the information contained in the full Hessian matrix.</p>
<p>The evidence framework also naturally handles the multiple scales of uncertainty present in neural networks. Parameter uncertainty captures the uncertainty in individual weight values given the training data, while hyperparameter uncertainty reflects uncertainty about the appropriate level of regularization or architectural choices. Model uncertainty encompasses uncertainty about the fundamental model class or architecture family. The hierarchical Bayesian treatment allows simultaneous reasoning about all these sources of uncertainty within a unified framework.</p>
<p>Contemporary applications of the evidence framework extend beyond traditional supervised learning to include unsupervised learning, reinforcement learning, and generative modeling. In variational autoencoders, for example, the evidence framework provides principled methods for selecting latent dimensionalities and regularization strengths. In Bayesian neural networks, the evidence guides the selection of prior distributions and network architectures while providing uncertainty quantification for predictions.</p>
<p>Despite its theoretical elegance, the evidence framework faces practical limitations in very large-scale applications. The computational requirements of Hessian approximation, even with modern efficient methods, can be substantial for networks with hundreds of millions of parameters. The Laplace approximation itself may be inadequate when the posterior is highly non-Gaussian, which can occur in networks with many local minima or complex loss landscapes.</p>
<p>Recent developments in the field have sought to address these limitations through alternative approximation schemes and computational innovations. Variational approaches replace the Laplace approximation with more flexible posterior approximations, while sampling-based methods use advanced MCMC techniques to explore the posterior distribution more thoroughly. These developments maintain the conceptual advantages of the evidence framework while extending its applicability to the scale and complexity of modern deep learning applications.</p>
<p>The enduring value of MacKay’s evidence framework lies in its principled approach to the fundamental trade-offs in machine learning model design. By providing a theoretically grounded method for balancing model complexity against data fit, the framework offers insights that remain relevant even as the scale and sophistication of machine learning models continue to evolve. The automatic hyperparameter selection and architecture comparison capabilities of the evidence framework continue to influence contemporary approaches to neural architecture search and automated machine learning.</p>
</section>
</section>
<section id="widely-applicable-bayesian-information-criterion" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="widely-applicable-bayesian-information-criterion"><span class="header-section-number">1.7</span> Widely applicable Bayesian Information Criterion</h2>
<p>The Widely applicable Bayesian Information Criterion (WBIC) is a generalization of the traditional BIC that addresses some of its fundamental limitations, particularly when dealing with singular statistical models and complex machine learning architectures. WBIC was developed by Sumio Watanabe as part of his singular learning theory, which provides a mathematical framework for understanding the behavior of statistical models that don’t satisfy the regularity conditions assumed by classical statistical theory.</p>
<section id="motivation-for-wbic" class="level3" data-number="1.7.1">
<h3 data-number="1.7.1" class="anchored" data-anchor-id="motivation-for-wbic"><span class="header-section-number">1.7.1</span> Motivation for WBIC</h3>
<p>The standard BIC, while useful, relies on several restrictive assumptions that often fail in modern machine learning contexts. First, BIC assumes that the true parameter lies in the interior of the parameter space and that the Fisher information matrix is positive definite. These regularity conditions fail for many important models such as neural networks with hidden units, mixture models where the number of components is unknown, tree-based models with unknown structure, and models with parameter constraints or boundaries.</p>
<p>Second, BIC requires knowing the effective number of parameters <span class="math inline">\(k\)</span>, which can be ambiguous for complex models. This becomes problematic when dealing with shared parameters across different parts of the model, regularization that effectively reduces the parameter dimension, or hierarchical structures where the effective dimensionality depends on the data. The challenge of defining the “true” number of parameters in modern machine learning models makes BIC’s penalty term difficult to specify correctly.</p>
<p>Third, BIC’s theoretical guarantees assume large sample sizes, but its performance can be poor for finite samples, especially when the model is complex relative to the data size. This limitation is particularly relevant in contemporary applications where high-dimensional models are applied to moderate-sized datasets, a common scenario in domains such as genomics, natural language processing, and computer vision.</p>
<p>WBIC addresses these limitations through a temperature-based approach that connects Bayesian model selection to statistical mechanics. The WBIC is defined as:</p>
<p><span class="math display">\[
\text{WBIC} = 2n \mathbb{E}_{\beta^{-1}}[\log p(D|\theta)] - 2 \log \int p(D|\theta)^{\beta} p(\theta) d\theta
\]</span></p>
<p>where <span class="math inline">\(\beta = 1/\log n\)</span> is an inverse temperature parameter that decreases as the sample size <span class="math inline">\(n\)</span> increases, and <span class="math inline">\(\mathbb{E}_{\beta^{-1}}[\cdot]\)</span> denotes expectation with respect to the posterior distribution at inverse temperature <span class="math inline">\(\beta^{-1}\)</span>.</p>
<p>More practically, WBIC can be computed as:</p>
<p><span class="math display">\[
\text{WBIC} = \frac{1}{T} \sum_{t=1}^{T} \left[ -2 \log p(D|\theta^{(t)}) \right]
\]</span></p>
<p>where <span class="math inline">\(\{\theta^{(t)}\}_{t=1}^{T}\)</span> are samples from the tempered posterior distribution:</p>
<p><span class="math display">\[
p_{\beta}(\theta|D) \propto p(D|\theta)^{\beta} p(\theta)
\]</span></p>
<p>with <span class="math inline">\(\beta = 1/\log n\)</span>.</p>
<p><strong>The temperature</strong> parameter <span class="math inline">\(\beta = 1/\log n\)</span> serves several important purposes in the WBIC framework. As the sample size <span class="math inline">\(n\)</span> increases, <span class="math inline">\(\beta\)</span> decreases, making the tempered posterior more diffuse than the standard posterior. This provides automatic regularization that prevents overfitting by spreading the posterior probability over a wider range of parameter values. The temperature mechanism allows WBIC to work with singular models where the standard likelihood-based methods fail, addressing one of the key limitations of traditional information criteria.</p>
<p>Unlike BIC’s asymptotic approximation, WBIC provides finite-sample corrections that improve performance for moderate sample sizes. This is particularly valuable in practical applications where the asymptotic regime may not be reached or where the effective sample size is reduced due to high-dimensional parameter spaces.</p>
<p>When the regularity conditions hold and the sample size is large, <strong>WBIC converges to BIC</strong>:</p>
<p><span class="math display">\[
\lim_{n \to \infty} \text{WBIC} = \text{BIC} = -2\log p(D|\hat{\theta}) + k \log n
\]</span></p>
<p>However, for singular models or finite samples, WBIC can provide substantially different and often more accurate model selection results. The convergence property ensures that WBIC maintains the desirable asymptotic properties of BIC while extending its applicability to a much broader class of models.</p>
<p>The WBIC naturally implements Occam’s razor through its temperature mechanism. Simpler models with fewer effective parameters receive higher weight because they have smaller variance in their log-likelihood values, the temperature averaging tends to favor models with more concentrated likelihood surfaces, and complex models are automatically penalized through the integral term in the WBIC expression. This automatic penalty adjustment is particularly valuable when the effective number of parameters is difficult to determine a priori.</p>
</section>
<section id="practical-implementation" class="level3" data-number="1.7.2">
<h3 data-number="1.7.2" class="anchored" data-anchor-id="practical-implementation"><span class="header-section-number">1.7.2</span> Practical Implementation</h3>
<p>Computing WBIC requires sampling from a tempered posterior, which can be accomplished through several computational approaches. Tempered MCMC modifies standard MCMC algorithms to sample from <span class="math inline">\(p_{\beta}(\theta|D)\)</span> instead of the standard posterior, requiring adjustments to the acceptance probabilities and proposal distributions. Parallel tempering runs multiple MCMC chains at different temperatures and uses the chain at <span class="math inline">\(\beta = 1/\log n\)</span>, which can be computationally intensive but provides robust sampling. When MCMC is computationally prohibitive, variational approximation methods can be used to approximate the tempered posterior, trading some accuracy for computational efficiency.</p>
<p>Here’s a simple example of how WBIC might be computed for a Bayesian linear regression model:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute WBIC for Bayesian linear regression</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>compute_wbic <span class="ot">&lt;-</span> <span class="cf">function</span>(X, y, <span class="at">prior_precision =</span> <span class="dv">1</span>) {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(y)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  beta_temp <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">/</span> <span class="fu">log</span>(n)  <span class="co"># Temperature parameter</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Set up tempered posterior sampling</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (This is a simplified example - real implementation would use proper MCMC)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sample from tempered posterior</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  n_samples <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  log_likes <span class="ot">&lt;-</span> <span class="fu">numeric</span>(n_samples)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_samples) {</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sample theta from tempered posterior p(theta|D)^beta</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... MCMC sampling code ...</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute log-likelihood at sampled theta</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    log_likes[i] <span class="ot">&lt;-</span> <span class="fu">compute_log_likelihood</span>(theta_sample, X, y)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># WBIC estimate</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  wbic <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">2</span> <span class="sc">*</span> <span class="fu">mean</span>(log_likes)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(wbic)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>WBIC offers several significant advantages over traditional information criteria. It works with singular models where BIC fails, provides finite-sample corrections that improve performance in practical applications, automatically handles effective parameter counting without requiring explicit specification, is theoretically grounded in singular learning theory, and often provides more accurate model selection for complex models. These properties make WBIC particularly valuable for modern machine learning applications where model singularities and complex parameter structures are common.</p>
<p>However, WBIC also has important limitations that practitioners should consider. It is computationally more expensive than BIC because it requires MCMC sampling rather than simple point estimates. It is less familiar to practitioners than standard information criteria, potentially creating barriers to adoption. Implementation can be complex for some model types, particularly when designing appropriate tempering schemes. Finally, while theoretically grounded, the practical properties of WBIC are less well-understood for some applications compared to the extensive literature on traditional information criteria.</p>
<p>The choice between WBIC and BIC depends on several factors related to the model, data, and computational constraints. WBIC is preferable when working with neural networks, mixture models, or other potentially singular models where BIC’s regularity assumptions fail. It is also advantageous when the effective number of parameters is unclear or when sample sizes are moderate and BIC’s asymptotic approximations may not be reliable. Additionally, WBIC should be considered when computational resources allow for the additional complexity of tempering and sampling procedures.</p>
<p>Conversely, BIC remains the better choice when working with simple, regular models such as linear regression or basic generalized linear models where the regularity conditions are satisfied. BIC is also preferable for large sample sizes where asymptotic approximations are accurate, when computational efficiency is paramount and the additional complexity of WBIC cannot be justified, or when the number of parameters is well-defined and small enough that BIC’s penalty term is appropriate.</p>
<p>WBIC represents an important advancement in Bayesian model selection, extending the applicability of information-theoretic model selection to the complex, high-dimensional models that are increasingly common in modern data science and machine learning applications. As the field continues to develop models that violate traditional statistical assumptions, tools like WBIC become essential for principled model comparison and selection.</p>
</section>
</section>
<section id="double-descent" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="double-descent"><span class="header-section-number">1.8</span> Double Descent</h2>
<p>Double descent is a phenomenon of over-parameterized statistical models. In this section, we present a view of double descent from a Bayesian perspective. Over-parameterized models such as deep neural networks have an interesting re-descending property in their risk characteristics. This is a recent phenomenon in machine learning and has been the subject of many studies. As the complexity of the model increases, there is a U-shaped region corresponding to the traditional bias-variance trade-off, but then as the number of parameters equals the number of observations and the model becomes one of interpolation, the risk can become infinite and then, in the over-parameterized region, it re-descends—the double descent effect. We show that this has a natural Bayesian interpretation. Moreover, we show that it is not in conflict with the traditional Occam’s razor that Bayesian models possess, in that they tend to prefer simpler models when possible.</p>
<p>Empirically, the double descent effect was initially observed for high-dimensional neural network regression models and the good performance of these models on such tasks as large language models, image processing, and generative AI methods<span class="citation" data-cites="nareklishvili2023generative">(<a href="references.html#ref-nareklishvili2023generative" role="doc-biblioref">Nareklishvili, Polson, and Sokolov 2023</a>)</span>. The double descent effect extends the classical bias-variance trade-off curve that shrinkage estimators possess. This phenomenon was first observed in the context of linear regression<span class="citation" data-cites="belkin2019reconciling">(<a href="references.html#ref-belkin2019reconciling" role="doc-biblioref">Belkin et al. 2019</a>)</span>. The authors showed that the test error of the estimator can decrease as the number of parameters increases. <span class="citation" data-cites="bach2024highdimensional">Bach (<a href="references.html#ref-bach2024highdimensional" role="doc-biblioref">2024</a>)</span> extends these results to stochastic regression models.</p>
<p>Interpolators—estimators that achieve zero training error—were then shown to have attractive properties due to the double descent effect<span class="citation" data-cites="hastie2022surprises">(<a href="references.html#ref-hastie2022surprises" role="doc-biblioref">Hastie et al. 2022</a>)</span>. Our goal is to show that Bayesian estimators can also possess a double descent phenomenon. Interpolators such as ReLU neural networks<span class="citation" data-cites="polson2017deep">(<a href="references.html#ref-polson2017deep" role="doc-biblioref">Polson, Sokolov, et al. 2017</a>)</span> have increased in popularity with many applications such as traffic flow modeling<span class="citation" data-cites="polson2017deep">(<a href="references.html#ref-polson2017deep" role="doc-biblioref">Polson, Sokolov, et al. 2017</a>)</span> and high-frequency trading<span class="citation" data-cites="dixon2019deep">(<a href="references.html#ref-dixon2019deep" role="doc-biblioref">Dixon, Polson, and Sokolov 2019</a>)</span>, among many others.</p>
<p>Occam’s razor—the favoring of simpler models over complex ones—is a natural feature of Bayesian methods that are based on the weight of evidence (a.k.a. the marginal likelihood of the data). To do this, they penalize models with higher complexity via a correction term as in the Bayesian Information Criterion (BIC). This seems inconsistent with the double descent phenomenon. We show that this is not the case, as even though Bayesian methods shift the posterior towards lower-complexity models, highly parameterized Bayesian models can also have good risk properties due to the conditional prior of parameters given the model. We illustrate this with an application to neural network models.</p>
<p>Double descent has been studied from a frequentist point of view in <span class="citation" data-cites="belkin2019reconciling">Belkin et al. (<a href="references.html#ref-belkin2019reconciling" role="doc-biblioref">2019</a>)</span>, <span class="citation" data-cites="bach2024highdimensional">Bach (<a href="references.html#ref-bach2024highdimensional" role="doc-biblioref">2024</a>)</span>. The phenomenon of double descent is illustrated in <span class="quarto-unresolved-ref">?fig-double-descent</span>. The first part of the curve represents the classical U-shaped bias-variance trade-off. The second part demonstrates the double descent phenomenon, where the test error of the estimator can decrease as the model becomes over-parameterized beyond the interpolation threshold. This phenomenon was later observed in the context of deep learning<span class="citation" data-cites="nakkiran2021deep">(<a href="references.html#ref-nakkiran2021deep" role="doc-biblioref">Nakkiran et al. 2021</a>)</span>. The authors showed that the test error of the estimator can decrease as the number of parameters increases.</p>
<div id="exm-double-descent" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.7 (Double Descent Demonstration using Polynomial Regression)</strong></span> To illustrate the double descent phenomenon in a concrete setting, we present a detailed example using polynomial regression with Legendre basis functions. This example demonstrates how the test error can exhibit the characteristic U-shaped curve followed by a re-descent as model complexity increases far beyond the interpolation threshold.</p>
<p>Our demonstration uses a one-dimensional regression problem where we attempt to learn a sinusoidal function <span class="math inline">\(f(x) = \sin(5x)\)</span> from a small dataset of only <span class="math inline">\(n = 20\)</span> observations sampled from the interval <span class="math inline">\([-1, 1]\)</span>. We add Gaussian noise with standard deviation <span class="math inline">\(\sigma = 0.3\)</span> to simulate realistic measurement error. The choice of a small sample size is crucial for observing double descent, as it creates a regime where the number of model parameters can substantially exceed the number of observations.</p>
<p>We fit polynomial models of varying degrees <span class="math inline">\(d = 1, 2, \ldots, 50\)</span> using Legendre polynomial basis functions. Legendre polynomials provide a numerically stable orthogonal basis that helps avoid the numerical instabilities associated with standard monomial bases in high-degree polynomial fitting. For each degree <span class="math inline">\(d\)</span>, we estimate the coefficients using the Moore-Penrose pseudoinverse, which provides the minimum-norm solution when the system is overdetermined (i.e., when <span class="math inline">\(d &gt; n\)</span>).</p>
<p><a href="#fig-double-descent-grid" class="quarto-xref">Figure&nbsp;<span>1.9</span></a> illustrates how model behavior changes dramatically across different polynomial degrees. The four panels show representative cases that capture the key phases of the double descent phenomenon:</p>
<ul>
<li><p><strong>Degree 1 (Underparameterized)</strong>: The linear model is too simple to capture the oscillatory nature of the underlying sine function, resulting in high bias and poor fit to both training and test data.</p></li>
<li><p><strong>Degree 5 (Classical Optimum)</strong>: This represents the sweet spot of the classical bias-variance tradeoff, where the model has sufficient complexity to capture the main features of the sine function without overfitting severely.</p></li>
<li><p><strong>Degree 20 (Interpolation Threshold)</strong>: At this degree, the model has exactly as many parameters as training observations, enabling perfect interpolation of the training data. However, the resulting fit exhibits wild oscillations between data points, leading to poor generalization performance.</p></li>
<li><p><strong>Degree 50 (Over-parameterized)</strong>: Surprisingly, despite having far more parameters than observations, this highly over-parameterized model achieves better test performance than the interpolating model, demonstrating the double descent effect.</p></li>
</ul>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">20</span>  <span class="co"># number of samples</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.3</span>  <span class="co"># stdev of noise</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">1</span>  <span class="co"># range of x values</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Use Legendre polynomial basis by default</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> np.polynomial.legendre.legvander</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> poly(pts, beta, d):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> G(pts, d).dot(beta)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize data</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>ground_truth <span class="op">=</span> sin</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(a, b, n)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> ground_truth(x) <span class="op">+</span> sigma <span class="op">*</span> np.random.normal(size<span class="op">=</span>n)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>xdense <span class="op">=</span> np.linspace(a, b, <span class="dv">100</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>ygt <span class="op">=</span> ground_truth(xdense)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Core functions</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve_reg(A, y, lamb):</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> la.solve(A.T.dot(A) <span class="op">+</span> lamb <span class="op">*</span> np.identity(A.shape[<span class="dv">1</span>]), A.T.dot(y))</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit(d):</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    betaHat <span class="op">=</span> la.pinv(G(x, d)).dot(y)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    mseos <span class="op">=</span> np.sqrt(np.mean((G(xdense, d).dot(betaHat) <span class="op">-</span> ygt)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    mseis <span class="op">=</span> np.sqrt(np.mean((G(x, d).dot(betaHat) <span class="op">-</span> y)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> betaHat, mseos, mseis</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run(d, ax):</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute the regressor for degree d, and plot the solution."""</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    betaHat, mseos, mseois <span class="op">=</span> fit(d)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    ax.plot(xdense, ygt, label<span class="op">=</span><span class="st">'ground-truth'</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    ax.scatter(x, y, c<span class="op">=</span><span class="st">'r'</span>, label<span class="op">=</span><span class="st">'samples'</span>)</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    ax.plot(xdense, poly(xdense, betaHat, d), label<span class="op">=</span><span class="st">'model'</span>)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">'d=</span><span class="sc">%d</span><span class="st">, MSE: Test=</span><span class="sc">%.2f</span><span class="st">, Train=</span><span class="sc">%.2f</span><span class="st">'</span> <span class="op">%</span> (d, mseos, mseois))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create 2x2 subplot grid (all functions and variables are now persistent!)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">'Double Descent Phenomenon: Polynomial Regression'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each degree in its respective subplot</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>run(<span class="dv">1</span>, axes[<span class="dv">0</span>, <span class="dv">0</span>])   <span class="co"># Top left</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>run(<span class="dv">5</span>, axes[<span class="dv">0</span>, <span class="dv">1</span>])   <span class="co"># Top right  </span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>run(<span class="dv">20</span>, axes[<span class="dv">1</span>, <span class="dv">0</span>])  <span class="co"># Bottom left</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>run(<span class="dv">50</span>, axes[<span class="dv">1</span>, <span class="dv">1</span>])  <span class="co"># Bottom right</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-double-descent-grid" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-double-descent-grid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="19-select_files/figure-html/fig-double-descent-grid-1.png" class="img-fluid figure-img" width="1152">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-double-descent-grid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.9: Double Descent Phenomenon: Polynomial Regression with Different Degrees
</figcaption>
</figure>
</div>
</div>
</div>
<p>Now, let’s plot the MSE curve. We will plot the test error (blue line) and the training error (red line) for different polynomial degrees from 1 to 50.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate MSE data for different polynomial degrees (using persistent functions!)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>nd <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>mse1 <span class="op">=</span> np.zeros(nd)  <span class="co"># Test MSE</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>mse2 <span class="op">=</span> np.zeros(nd)  <span class="co"># Train MSE</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nd):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    betaHat, mseos, mseois <span class="op">=</span> fit(d)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    mse1[d] <span class="op">=</span> mseos</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    mse2[d] <span class="op">=</span> mseois</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>fig, ax1 <span class="op">=</span> plt.subplots()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Number of Features'</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'MSE'</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>ax1.plot(np.log10(mse1), color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'out-of-sample'</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> ax1.twinx()</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>ax2.plot(np.log10(mse2), color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'in-sample'</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.plot(mse1, label='out-of-sample')</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.plot(mse2, label='in-sample')</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>fig.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-mse-curve" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mse-curve-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="19-select_files/figure-html/fig-mse-curve-3.png" class="img-fluid figure-img" width="576">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mse-curve-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.10: Bias-Variance Trade-off: Training and Test MSE vs Model Complexity
</figcaption>
</figure>
</div>
</div>
</div>
<p>The key insight from <a href="#fig-mse-curve" class="quarto-xref">Figure&nbsp;<span>1.10</span></a> is the characteristic double descent shape in the test error (blue line). The curve exhibits three distinct phases:</p>
<ol type="1">
<li><p><strong>Classical Regime</strong>: For low degrees (<span class="math inline">\(d &lt; 5\)</span>), increasing model complexity reduces both bias and test error, following the traditional understanding of the bias-variance tradeoff.</p></li>
<li><p><strong>Interpolation Crisis</strong>: Around the interpolation threshold (<span class="math inline">\(d \approx n = 20\)</span>), test error peaks dramatically as the model begins to perfectly fit the training data while generalizing poorly.</p></li>
<li><p><strong>Over-parameterized Regime</strong>: For very high degrees (<span class="math inline">\(d &gt; 30\)</span>), test error decreases again, demonstrating that extreme over-parameterization can lead to improved generalization despite the model’s ability to memorize the training data.</p></li>
</ol>
<p>This behavior challenges the conventional wisdom that more parameters necessarily lead to worse generalization. The double descent phenomenon arises from the implicit regularization effects of minimum-norm solutions in over-parameterized settings. When <span class="math inline">\(d &gt; n\)</span>, the pseudoinverse solution corresponds to the minimum <span class="math inline">\(\ell_2\)</span>-norm coefficients among all possible interpolating solutions. This implicit bias toward simpler functions can lead to surprisingly good generalization properties.</p>
<p>While this example uses polynomial regression for clarity, the double descent phenomenon has been observed across a wide range of modern machine learning models, including deep neural networks, random forests, and kernel methods. The implications for practice are significant. Given that model selection is time consuming and computationally expensive, this example shows, that instead of spending time to do model selection to find the “sweet spot” model with 5-degree polynomial, we just over-parametrise and get a good model for free!</p>
<p>This example serves as a concrete illustration of how classical statistical intuitions about model complexity may not apply in contemporary machine learning settings, particularly when dealing with over-parameterized models that have become increasingly common in practice.</p>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-bach2024highdimensional" class="csl-entry" role="listitem">
Bach, Francis. 2024. <span>“High-Dimensional Analysis of Double Descent for Linear Regression with Random Projections.”</span> <em>SIAM Journal on Mathematics of Data Science</em> 6 (1): 26–50.
</div>
<div id="ref-belkin2019reconciling" class="csl-entry" role="listitem">
Belkin, Mikhail, Daniel Hsu, Siyuan Ma, and Soumik Mandal. 2019. <span>“Reconciling Modern Machine-Learning Practice and the Classical Bias–Variance Trade-Off.”</span> <em>Proceedings of the National Academy of Sciences</em> 116 (32): 15849–54.
</div>
<div id="ref-dixon2019deep" class="csl-entry" role="listitem">
Dixon, Matthew F, Nicholas G Polson, and Vadim O Sokolov. 2019. <span>“Deep Learning for Spatio-Temporal Modeling: Dynamic Traffic Flows and High Frequency Trading.”</span> <em>Applied Stochastic Models in Business and Industry</em> 35 (3): 788–807.
</div>
<div id="ref-hastie2022surprises" class="csl-entry" role="listitem">
Hastie, Trevor, Andrea Montanari, Saharon Rosset, and Ryan J. Tibshirani. 2022. <span>“Surprises in High-Dimensional Ridgeless Least Squares Interpolation.”</span> <em>The Annals of Statistics</em> 50 (2): 949–86.
</div>
<div id="ref-lindley1961use" class="csl-entry" role="listitem">
Lindley, D. V. 1961. <span>“The <span>Use</span> of <span>Prior Probability Distributions</span> in <span>Statistical Inference</span> and <span>Decisions</span>.”</span> In <em>Proceedings of the <span>Fourth Berkeley Symposium</span> on <span>Mathematical Statistics</span> and <span>Probability</span>, <span>Volume</span> 1: <span>Contributions</span> to the <span>Theory</span> of <span>Statistics</span></em>, 4.1:453–69. University of California Press.
</div>
<div id="ref-mackay1992bayesian" class="csl-entry" role="listitem">
MacKay, David JC. 1992. <span>“Bayesian Interpolation.”</span> <em>Neural Computation</em> 4 (3): 415–47.
</div>
<div id="ref-nakkiran2021deep" class="csl-entry" role="listitem">
Nakkiran, Preetum, Gal Kaplun, Yamini Bansal, Tristan Yang, Boaz Barak, and Ilya Sutskever. 2021. <span>“Deep Double Descent: Where Bigger Models and More Data Hurt*.”</span> <em>Journal of Statistical Mechanics: Theory and Experiment</em> 2021 (12): 124003.
</div>
<div id="ref-nareklishvili2023generative" class="csl-entry" role="listitem">
Nareklishvili, Maria, Nicholas Polson, and Vadim Sokolov. 2023. <span>“Generative <span>Causal Inference</span>,”</span> June.
</div>
<div id="ref-polson2017deep" class="csl-entry" role="listitem">
Polson, Nicholas G, Vadim Sokolov, et al. 2017. <span>“Deep <span>Learning</span>: <span>A Bayesian Perspective</span>.”</span> <em>Bayesian Analysis</em> 12 (4): 1275–1304.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./00-intro.html" class="pagination-link" aria-label="Principles of Data Science">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Principles of Data Science</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>